<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Electron Hacking for Beginners</title>

    <meta name="description" content="A gentle introduction to becoming productive in a very large codebase">
    <meta name="author" content="Charles Kerr">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/night.css" id="theme">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-markdown data-separator-notes="XXX" id="title-page">
          ## Electron Hacking for Beginners
          #### A gentle introduction to becoming productive in a very large codebase

          XXX
          Hi, I'm Charles Kerr. I'm part of the Electron team at Microsoft.

          Before that I worked for about five years on Ubuntu Linux,

          and before that I wrote most of the BitTorrent app named Transmission.

          So I've done open source for awhile now.
        </section>

        <section id="intent">
          <p>Electron's developer community is high-quality,<br/>but small</p>
          <p>&nbsp;</p>
          <p>This walkthrough shows how get started on Electron and why it's not as scary as you think.</p>
          <p>&nbsp;</p>
          <p class="fragment" style=font-size:smaller">1. The Tools <i>(getting the code)</i></p>
          <p class="fragment" style=font-size:smaller">2. The Code <i>(building & understanding the code)</i></p>
          <p class="fragment" style=font-size:smaller">3. Putting it into Practice <i>(changing the code)</i></p>
          <aside class="notes">
          <p>In a lot of ways we're a traditional open source project:
             we've got a CoC, governance structure, small team from a
             frustrating number of timezones, etc.</p>

          <p>But <em>unlike</em> a lot of open source projects, at least the
             ones I've worked on, nearly all maintainers are from companies
             that rely on Electron commercially, and nearly all the patches
             come from them.</p>

          <p>So why don't we see more volunteers? Electron is MIT licensed,
             with no CLA, so it's not the license. And the number of apps
             using Electron is amazing, so it's not a lack of interested
             parties, so it's not a lack of interested parties.</p>

          <p>I think what's going on is Electron's got a reputation that its
             code is <em>too</em> big and <em>too</em> scary. This presentation
             is to push back on that a little and encourage you to dive in.
             I'll do this in three parts:</p>

          <p><b>fragment</b> The tools. Building Electron takes a few tools you've used and a few weird ones you haven't, unless you're paid write web browsers.</p>

          <p><b>fragment</b> The code. Yes, the codebase is big. Really big. You won't believe how mind-bogglingly big it is. But I'll explain why that's OK and why you might understand more of it than you expect.</p>

          <p><b>fragment</b> Lastly, putting it into practice. We'll walk through a real Electron bug that was reported about a month ago and fix it.</p>

          </aside>
        </section>

        <section data-markdown data-separator-notes="XXX" id="part-1-the-tools">
          #### Part 1 of 3
          ## The Tools

          XXX
          And all this should run about 20-25 minutes.

          Okay so let's start with the tools.
        </section>

        <section data-markdown data-separator-notes="XXX" id="os-specific-prerequisites">
          ### OS-specific prerequisites

          Instructions at [electronjs.org/docs/](https://electronjs.org/docs/development/build-instructions-gn)

          You've probably done this before.

          * Ex: installing Python 2.7 on macOS with `brew`
          * Ex: installing [Node.js](https://nodejs.org/)

          XXX
          There are platform-specific tools you need to install first.

          These are documented at electronjs.org/docs and I'm going to skip past them because most developers have already used or heard of these and so ... they're not scary.

          For example if you're attending an Electron conference, you've probably installed Node

          And if you're attending an Electron conference and have a Mac, and you've probably installed something using homebrew.

          So moving right along...
        </section>

        <section id="code-what-code">
          <h4>What gets built?</h4>
          <p class="fragment">Electron's Code</p>
          <p class="fragment">Node's Code</p>
          <p class="fragment" style="font-size:small">http_parser, llhttp, nghttp2, zlib, brotli, v8</p>
          <p class="fragment">Chromium's Code</p>
          <p class="fragment" style="font-size:small">Skia, Views, fido, mojo, libdbus, libaccessability, libpdf, libprotocol, ppapi, libnetwork_service, libgl_wrapper, libbluetooth</p>
          <p class="fragment" style="font-size:small">angle, blink, boringssl, breakpad, brotli, cacheinvalidation, ced, cld_3, crashpad, dav1d, dom_distiller, fontconfig, hunspell, iccjpeg, libsecret, srtp, vpx, webm, webp, libxml2, libxslt, libyuv, liblzma, libmodp_b64, openh264, opus, perfetto, pffft, protobuf, re2, sfntly, smhasher, snappy, sqlite, swiftshader, unrar, webrtc, yasm, zlib</p>
          <aside class="notes">
          When we're building Electron, what do we build?

          Pretty much what you'd expect: Electron is APIs + Node + Chromium, so that's what gets built.

          That sounds simple, but as you might have guessed from the talk's title, it's really not.

          It's all compiled together.
          And that's important, because doing so ensures
          for example that Chromium and Node are linking against the same version of V8,
          and that everything's built with compatible build flags.
          </aside>
        </section>

        <section data-markdown data-separator-notes="XXX" id="sloccount-all">
          ### So that's a lot of code?

          ```sh
          ~/electron/electron-gn/master/src$ cloc *
          C++           20,582,258
          C/C++ Header   7,477,199
          JavaScript     7,116,240
          C              3,857,228
          Python         2,143,884
          TypeScript       245,664
          ...
          SUM:          59,751,830
          ```

          **Yes.**
          XXX
          And here we reach the point where I think Electron gets its reputation from,
          that might scares away some aspiring contributors.

          By the way, that counting tool removes duplicate files from the count.

          So tools, config, and boilerplate got copied into multiple repos, none of those is part of that number.

          Imagine how many repos you have to clone for that.

          Imagine even tracking the dependencies to know what repos you'd need and keeping them all in sync.
        </section>

        Slides:
        * Can't just `npm install`: deps for specific commits between releases. Also, it patches on top of them. And Electron patches on top of <em>that</em>.
        * Chromium has depot tools, which has meta-checkout and meta-build tools like gclient and gn. (gn: generate ninja)
        * Electron has build-tools, which handles basic checkout and build, and has bells &amp; whistles for setting up git caching correctly, for keeping depot tools up-to-date, for picking up sccache files from our CI builds to speed up your build time,, convenience tools for debugging, etc.
        * Quick intro to `e init --bootstrap`
        * Building Chromium is now a benchmark
        * What is the cost (build time, checkout time, cache size)

        <section id="the-code">

        Slides:
        
        <section data-markdown data-separator-notes="XXX" id="sloccount-more-relevant">
          Chromium code more relevant to Electron

          ```sh
          $ rg --no-filename "^#include \"" | grep -v -e shell -e electron \
             | perl -pe "s/\"(\w*?)\/(?:.*)\"/\$1/" \
             | grep -v -e "\.h\"" | sort | uniq -c | sort -nr | head -n8
          972 #include base
          423 #include content
          358 #include ui
          145 #include third_party
          106 #include components
          98 #include gin
          95 #include extensions
          92 #include services

          $ cloc --quiet --json base content ui third_party/skia \
            third_party/blink components gin extensions \
            services | json SUM.code
          11,645,172
          ```

          XXX
          So now we're down to only 11 million lines of code.

          Not so scary now, right? 

          That's a cognitive bias technique called anchoring.
          I'm trying to make 11 million lines seem less scary now
          because, hey, it's not 59 million.

          11 million is still a little scary, though.
          How big is Electron on its own?
        </section>

        <section data-markdown data-separator-notes="XXX" id="sloccount-electron">
          **Electron codebase**

          ```sh 
          ~/electron/electron-gn/src/electron$ cloc shell lib script patches
          C++             43,474
          C/C++ Header    14,700
          JavaScript       8,405
          Objective C++    7,485
          TypeScript       3,394
          ...
          SUM             80,439
          ```

          XXX
          Electron itself: about 80 thousand lines.
        </section>

        <section data-markdown data-separator-notes="XXX" id="tell-me-what-electron-builds-look-like-this-is-what-electron-builds-look-like">
FIXME move this slide to part 1
          ```sh
FIXME `s/ninja/e make/`
          $ TIME="%e seconds" /usr/bin/time \
            ninja -C $EL_GN_PATH/src/out/debug \
            electron:electron_app
          [18098/18098] LINK ./electron
          398.03 seconds
          $ du -sh ~/.electron-cache/sccache
          1.6G	/home/charles/.electron-cache/sccache

          ```

          ```sh
          $ $EL_GN_PATH/src/electron/external_bins/sccache --stats
FIXME REDO
           11164 Compile requests
           11146 Compile requests executed
           11142 Cache hits
               3 Cache misses
              18 Non-cacheable calls
           0.005 s Average cache write
          21.994 s Average cache read miss
           0.021 s Average cache read hit
          Cache location
          Local: Local disk: "/home/charles/.electron-cache/sccache"
          Remote: S3, bucket: Bucket(name=electronjs-sccache,
            base_url=http://electronjs-sccache.s3.amazonaws.com/)
          Cache size 2 GiB
          Max cache size 10 GiB
          ```
          XXX
          This page has a lot going on.

          1. Yes, that's eighteen thousand and 98 build steps.

          2. compile took 398 seconds -- under 7 minutes. **YES** that was with a
          hot cache and **YES** it's going to take longer with a Walmart Windows tablet...
          but without caching on this same machine it would take many hours.
          Hard to overstate how big a win this is.

          3. the cache has grown again, another couple GB to sccache this time.

          4. you can see at the bottom there, the s3 CI cache is working

          So the scary numbers and stats end on a happy note here.

          Let's take a really quick look at the source.

        </section>

        (this picks up after the LOC and we say it's "only" 7 million)
SLIDE: getting around the codebase

These next two minutes are fast run through the codebase.
Don't panic!
You don't need to remember any of the class names.
The goal here is to show you the general layout and how things connect together.

        * base: general-purpose utilities used by everyone else. e.g string tokenizing, logging, etc.
        * components:  directory for components that have the Content Module as the uppermost layer they depend on. (e.g. printing)
        * blink: rendering and layout
        * ui/views: simple framework for abstracting native windows
        * gin: convenience utilities for v8
        * services: cross-platform management of services. (e.g. platform-specific parts of sensor API, safe data decoding inside sandboxed processes). this may sound a little like components; the difference is the API surface for services is entirely via IPC, no link-time or runt-ime exposure, no sharing of global state.

SLIDE: content
        * content: The core code needed for a multi-process sandboxed browser. It includes all the web platform features (i.e. HTML5) and GPU acceleration. It does not include Chrome features, e.g. extensions/autofill/spelling etc.

        The current status is content doesn't depend on chrome at all (see the meta bug and all bugs it depends on). We now have a basic browser built on top of content (“content_shell”) that renders pages using content on all platforms. This allow developers working on the web platform and core code to only have to build/test content, instead of all of chrome.

         ~/electron/gn/master/src/content/public  88c84e124dc8  ls                                                                            ✔  2020-01-15 22:36 CST wk03
android  app  browser  child  common  DEPS  gpu  PRESUBMIT.py  README.md  renderer  test  utility

 ~/electron/gn/master/src/electron/shell  master  ls                                                                                  ✔  2020-01-15 22:37 CST wk03
app  browser  common  renderer  utility

 ~/electron/gn/master/src/electron/lib  master  ls                                                                                    ✔  2020-01-15 22:37 CST wk03
browser  common  content_script  isolated_renderer  renderer  sandboxed_renderer  worker

 ~/electron/gn/master/src  88c84e124dc8  cd content/shell                                                                             ✔  2020-01-15 22:45 CST wk03
ls
 ~/electron/gn/master/src/content/shell  88c84e124dc8  ls                                                                             ✔  2020-01-15 22:45 CST wk03
android  app  browser  BUILD.gn  common  DEPS  gpu  OWNERS  renderer  resources  shell_resources.grd  test_runner  tools  utility


SLIDE: siblings
        ./fuchsia/engine/browser/web_engine_browser_context.cc
./chromecast/browser/cast_browser_context.cc
./android_webview/browser/aw_browser_context.cc
./components/arc/test/test_browser_context.cc
./electron/shell/browser/atom_browser_context.cc
atom_browser_main_parts.cc
cast_browser_main_parts.cc
it's not a one-to-one

SLIDE: so, to connect all this together:

say you get a crash in electron/shell/browser/atom_browser_client.cc and you say to yourself "well I know all those words, what do they mean when you put them together like that?"

content/public/browser/content_browser_client.h"

```
  // Embedder API (or SPI) for participating in browser logic, to be implemented
  // by the client of the content browser. See ChromeContentBrowserClient for the
  // principal implementation. The methods are assumed to be called on the UI
  // thread unless otherwise specified. Use this "escape hatch" sparingly, to
  // avoid the embedder interface ballooning and becoming very specific to Chrome.
  // (Often, the call out to the client can happen in a different part of the code
  // that either already has a hook out to the embedder, or calls out to one of
  // the observer interfaces.)
  class CONTENT_EXPORT ContentBrowserClient {
```

and if you want to see the Chromium shell implemention for reference, 

`content/shell//browser/shell_content_browser_client.cc`.

        <section data-markdown data-separator-notes="XXX" id="the-biggest-class">
          ** Excerpt from the biggest, scariest class in Electron (atom::api::WebContents)**
          ```cpp
            void LoadURL(const GURL& url, const mate::Dictionary& opts);
            base::string16 GetTitle() const;
            bool IsLoading() const;
            void Stop();
            void ReloadIgnoringCache();
            void GoBack();
            void GoForward();
            bool IsCrashed() const;
            void SetUserAgent(const std::string& user_agent);
            std::string GetUserAgent();
            void InsertCSS(const std::string& css);
            void OpenDevTools(mate::Arguments* args);
          ```

          XXX
          Not completely unexpected, right?

          This <i>is</i> the largest class we've got.
          And you understand a lot of the ideas here already.

          To be clear: no, I'm not saying Electron is easy.
          Some of it is, but a lot of it isn't.

          You're probably not going to be refactoring NativeWindow
          or fixing Sandboxing on Linux on your first day.
          That comes at around the 8 month mark.

          But if you've written Electron apps,

          if you've used `win.loadURL()` or `win.getTitle()`,

          you already see the big picture, and that can be your guide
          when you're reading and learning the littler pictures.

          The implementation may be unfamiliar, but `OpenDevTools()` isn't alien. Right?
        </section>


SLIDE: crazy wall

That's as clear as an unmuddied lake, right? Don't worry.
After you read through a few million lines it all starts to make sense...

SLIDE: https://cs.chromium.org/ is your friend

You can also get your IDE to do some of this for you,
though intellisense on Chromium's codebase can be expensive.

Another option is to use Chromium Code Search at cs.chromium.org,
though that won't give you the Electron bits.

Step 3: using the code

SLIDE: In Action

Now, you know how to obtain and, given enough time, build one of the largest open source codebases in existence.

And you've got a good idea where to start looking for information when there's code that you don't understand,
how some some of those FIXME million puzzle pieces fit together.

FIXME: move this paragraph to the beginning.
Now for the hopeful part. If you know how to convert javascript to typescript, there's an ongoing project
to port our codebase over. If you've got experience with native Windows, Mac, or Linux development,
there's Electron that will benefit from your eyes.
If you've got experience writing clean tests in chai, wow, we'll love you.
If you're bilingual, the documentation project will love you.
If you've got experience in C++, in, say network code, or IPC, or sandboxing, those are useful in Electron.
Most importantly -- if you've got experience in <em>any</em> of these, and you're looking to gain more experience
in any of the others, Electron's huge domain space is suddenly an advantage.

OK so remember back to the beginning when I said if you've got chai, or IPC, or Windows, or Linux,
or X, Y or Z experience, there's probably a way to put it to use.

Here's an example. Also back in the beginning I said I worked on Ubuntu Linux before Electron,
so when I came here I knew almost nothing about web development.

Here's a bug that I fixed early on using only my knowledge of the Linux gui library GTK.
You don't need any GTK skills to follow along.
Just like you have skills that I don't, and you could probably use them to do things with Electron that I couldn't when I started on the project.


SLIDES: move the bugfix video to set of slides


        <section id="final-thoughts-on-code">
          <h3>Final thoughts on the codebase</h3>
          <ul>
          <li class="fragment">Electron is a good project for someone who knows X and wants to learn Y</li>
          <li class="fragment">You already understand more than you think</li>
          <li class="fragment">Don't Panic</li>
          </ul>
          <aside class="notes">
          <p>As said in the last slide, <b>(fragment)</b> you understand more than you think.</p>
          <p><b>(fragment)</b> When I started contributing to Electron, I'd never touched Node. So for me it was both unfamiliar *and* alien, and I stressed over that a lot.</p>
          <p>The thing to understand is you've got millions of lines of code -- <b>everyone</b> is lost to some degree.</p>
          <p>When I realized it's OK to be a <i>little</i> lost, that freed me up to stress about it less and focus and learn faster.</p>
          <p><b>(fragment)</b> As an aside, Chromium has a lot of solid engineering. [read fragment aloud here] The Chromium directory named `base/` holds general-use tools, mostly self-contained, so it's not a bad place to start. You'll find Chromium's string manipulation, memory management, callback binding, and so on.</p>
        </section>

        <section data-markdown data-separator-notes="XXX" id="in-practice">
          #### Part 3 of 3
          ## In Practice

          XXX
          To review: So far we've checked out 16 GB of source code

          and we've run 18 thousand and 98 build steps

          and we know what `win.openDevTools()` does

          So we're invincible, right?

          Let's get our hands dirty.

          As promised, here's a real bug that was reported about a month ago:
        </section>

        <section data-markdown data-separator-notes="XXX" id="bug-report" data-background="assets/bug-report.png">
          XXX
          The screenshot here says it all: on Linux, the `alert()` dialog is showing a No Symbol icon.

          This should be easy to test.
        </section>

        <section data-markdown data-separator-notes="XXX" data-background-video="assets/bugfix.webm" data-background-color="#000000">
          XXX
          make sure we have a fresh build

          let's run electron-quick-start

          open devtools

          and pull up an alert dialog.

          sure enough.

          Now, I'm pretending for this example I don't know whether Electron is using a GtkMessageDialog, a GtkDialog, or not using those at all but instead creating a custom GtkWindow.

          But I do know whatever it's using, that icon is getting shown by a call to gtk_widget_show(), because that's what every GTK+ widget uses, no matter what type of class is aggregating it.

          So I'll run the same test again inside a debugger and set gtk_widget_show() as a breakpoint.

          open devtools again...

          set the breakpoint... gdb is kind of slow.

          the alert again...

          cool. let's see where it's coming from.

          ok this noise here is C++'s version of the green terminal windows in the matrix. You get used to it.

          first thing I see here is it's in atom/browser/ui/message_box_gtk, which means it's likely our bug.

          I see an argument named 'icon' of type imageskia, so maybe someone is passing in a broken icon.

          let's open up atom/browser/ui/message_box_gtk line 49 and take a look.

          here's where the dialog is created, and sometimes these use a default icon depending on the dialog type.

          let's go back to the debugger and see what type was passed in.

          looks like that type is atom::MESSAGE_BOX_TYPE_NONE, so that's not the problem.

          Next I see us setting the dialog's image property if that imageskia isn't null.

          let's go back to the debugger and check.

          walk up the callstack

          and icon.isNull() is _true_, so this block of code is never reached, so this isn't the problem either.

          what else calls gtk_widget_show().

          here's a call that only happens when we have a checkbox label... that's not going to be it, but just for fun let's ask the debugger what checkbox_label is --

          yep, checkbox_label is an empty string.

          so let's keep looking for gtk_widget_show() calls.

          AH now this is promising.

          gtk_widget_show_all() tries to show its whole subtree of widgets, of UI components. 

          So maybe what's happening is GtkMessageDialog _always_ has an icon widget, but it's just not shown when the icon property's not set.

          If so, this call here would show that unset icon.

          That would be consistent with the no-icon symbol.

          Let's see what happens if we remove the `_all()` from this.

          rebuild

          restart the process

          pop up devools

          show an alert

          there we go!

          We got it.

          And although I knew some GTK+ to solve this bug, this one didn't really take any Electron.

          (fast transition to)
        </section>

        <section id="conclusions">
          <h3>What Have We Learned?</h3>
          <li class="fragment">Whether you know Electron, GTK+, Chromium, Node.js, Windows, JS, C++, Obj-C, Carbon, Linux, or Docker... those are <i>all</i> skills that you can use on Electron.</li>
        </section>

        <section data-markdown data-separator-notes="XXX" id="thanks">
          ### Thanks for listening!

          #### Further reading
          * https://electronjs.org/docs/development

          * https://cs.chromium.org/

          * https://www.chromium.org/developers/how-tos/getting-around-the-chrome-source-code

          * https://www.patreon.com/sindresorhus
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: false,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/search/search.js', async: true },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });
    </script>

  </body>
</html>
