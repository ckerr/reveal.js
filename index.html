<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Electron Hacking for Beginners</title>

    <meta name="description" content="A gentle introduction to a very large codebase">
    <meta name="author" content="Charles Kerr">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/night.css" id="theme">
    <style>
      .secondary_text {
        font-size: smaller;
        font-style: italic;
        filter: brightness(66%);
      }
      .reveal section .why_image {
        background-color: transparent;
        border: none;
        height: 200px;
        width: 150px;
      }
      .filename {
        font: courier;
        font-size: 0.8em;
        color: lime;
        background-color: #222;
        word-break: keep-all;
      }
      .url {
        color: #0f0;
        text-decoration: underline;
      }
    </style>

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section id="title-page">
          <h2>Electron Hacking for Beginners</h2>
          <p>A gentle introduction to a very large codebase</p>
          <p>&nbsp;</p>
          <p>Charles Kerr</p>
          <aside class="notes">
            <p>Hi, I'm Charles Kerr. I'm one of the Electron maintainers.</p>
            <p>And today I'm going to talk about why you should get involved with Electron's development, too.</p>
          </aside>
        </section>

        <section id="topics">
          <h3>Getting Involved!</h3>
          <ol>
            <li>Why?</li>
            <li>How?
              <ul>
                <li>Getting the code</li>
                <li>Building the code</li>
                <li>Understanding the code</li>
              </ul>
            </li>
            <li>Live coding demo</li>
          </ol>

          <aside class="notes">
          <p>So we'll go over why you would want to do that,</p>
          <p>how to do that,</p>
          <p> -- including the mechanics of getting and building the code, and importantly, finding your way around the code --</p>
          <p>and we'll put these ideas into action with a coding example.</p>
          <p>This talk will take about half an hour and, while it is about coding --
             there are lots of other ways to get involved.</p>
          <ul>
            <li>If you're bilingual, there is a project to translate our documentation.</li>
            <li>If you're involved with QA, we have a group of QA people from other Electron apps
               and you can come and learn from each other.</li>
            <li>If you have an app with a beta channel and you want to help us find bugs in
               Electron's betas, come talk to us.</li>
          </ul>
          </aside>
        </section>

        <section id="why-get-involved">
          <h3>Why Get Involved?</h3>
          <div style="display: grid; grid-template-columns: 3fr 1fr 1fr 1fr 1fr; grid-column-gap: 0.5em">
            <div class="fragment"><img class="why_image" src="assets/tux.png"> <img class="why_image" src="assets/mac-os.png"></div>
            <div class="fragment"><img class="why_image" src="assets/Light-bulb-icon.png"/></div>
            <div class="fragment"><img class="why_image" src="assets/bag-of-money.png"/></div>
            <div class="fragment"><img class="why_image" style="height: 150px; padding-top: 33px" src="assets/happy.png"/></div>
            <div class="fragment"><img class="why_image" src="assets/infinity-gauntlet.png"/></div>
          </div>
          <aside class="notes">
            <p>So, why get involved?</p>
            <p><b>FRAGMENT (show tux)</b></p>
            <p>First, maybe you're a developer who uses more than one desktop. Maybe you like it when the apps you use run on all of them.</p>
            <p>Not many companies write native apps for Linux, Mac, and Windows.</p>

            <p><b>FRAGMENT (show lightbulb)</b></p>
            <p>Maybe you want to put your skills to use while also learning new ones.
               Electron uses a <em>lot</em> of languages and tools.
               <ol>
                 <li>JavaScript</li>
                 <li>TypeScript</li>
                 <li>C++</li>
                 <li>Python</li>
                 <li>Objective C.</li>
                 <li>We use Mac APIs</li>
                 <li>Windows APIs</li>
                 <li>we use posix, GTK+, and dbus on Linux</li>
                 <li>our tests use chai</li>
                 <li>our CI uses docker</li>
                 <li>...and so many more. I literally could not name them all.</li>
               </ol></p>
            <p>And maybe that sounds overwhelming;
               but if you get just one thing from this talk, I want you to understand
               that <b>you can</b> do good things on Electron even if you only know one of those skills.
               <em>Nobody</em> understands the whole list, so you're in good company.</p>
            <p>Electron's code is big and isn't always easy, but it often it is.
               <b>You can</b> do good things on Electron even if you are just starting out.</p>

            <p><b>FRAGMENT (show bag of money)</b></p>
            <p>Maybe you're looking for better-paying work.</p>
            <p>There are a <b>lot</b> of apps shipping on Electron, but when an Application hits some weird issue,
               there aren't that many people who know how to dig into Electron's source and fix it.</p>
            <p>Electron will be better off when more people have these skills --
               and those new skilled people will probably be better of too.</p>
            <p>I heard the manager of one Electron app say that
               another team could take their Electron person
               over that manager's dead body.</p>

            <p><b>FRAGMENT (show smiley)</b></p>
            <p>Related to the last two, maybe you're looking for more <em>interesting</em> work.</p>
            <p>That long list of skills sounds scary if you think you have to know it all before starting.</p>
            <p>But if it's a list of things where you can pick and choose what to learn? That's kind of appealing!</p>

            <p><b>FRAGMENT (infinity gauntlet)</b></p>
            <p>Lastly, power and influence.</p>
            <p>Electron is a community-based project. We've got a governance structure,
               a code of conduct, maintainers around the world -- but full time,
               there's only about a dozen of us.</p>
            <p>Anyone in this room, if they wanted to invest the time,
               can go from having no say to having a very prominent say.</p>
            <p>As long as it's not to the detriment of others, we're very flexible</p>

          </aside>
        </section>

        <section id="code-what-code">
          <h4>What code do I need?</h4>
          Electron, Node, and Chromium
          <p class="fragment" sytle="font-size: 0.9em">...and Node's dependencies, like brotli, http_parser, llhttp, nghttp2, v8, zlib </p>
          <p class="fragment" style="font-size: 0.8em">...and Chromium's dependencies, like Skia, Views, fido, mojo, libdbus, libaccessability, libpdf, libprotocol, ppapi, libnetwork_service, libgl_wrapper, libbluetooth</class></p>
          <p class="fragment" style="font-size: 0.6em">...and the dependencies' dependencies, like angle, blink, boringssl, breakpad, brotli, cacheinvalidation, ced, cld_3, crashpad, dav1d, dom_distiller, fontconfig, hunspell, iccjpeg, libsecret, srtp, vpx, webm, webp, libxml2, libxslt, libyuv, liblzma, libmodp_b64, openh264, opus, perfetto, pffft, protobuf, re2, sfntly, smhasher, snappy, sqlite, swiftshader, unrar, webrtc, yasm, zlib</p>
          <aside class="notes">
            <p>Alright, so if any of that sounded interesting,
               the next thing to do is get the code.</p>

            <p>So, what do you need to get? Well as you know, Electron is Node plus Chromium plus features.</p>

            <p>And we compile all their sources to ensure everything's compatible.
               For example,
               everything needs to have the same compiler flags.
               And we also need to ensure that Chromium and Node use the same version of the javascript engine named V8.</p>

            <p><b>fragment</b>
            Oh yeah, v8. Node has some dependencies, and we need to build those too.</p>

            <p><b>fragment</b>
            And so does Chromium</p>

            <p><b>fragment</b>
            Oh, and Chromium's dependencies have dependencies.
            When you add everything up, it's about 60 million LOC.
            </p>
          </aside>
        </section>

        <section id="introducing-electron-build-tools">
          <p style="color: #f00; text-decoration: line-through;">$ brew install</p>
          <p style="color: #f00; text-decoration: line-through;">$ npm install</p>
          <p style="color: #f00; text-decoration: line-through;">$ sudo apt install</p>
          <p class="url">https://github.com/electron/build-tools</p>
          <aside class="notes">
          And for added fun, you can't just install them.
          Chromium's dependencies aren't specified by their version numbers; they use specific commit hashes.
          And Chromium has custom patches for its dependencies --
          so those have to be applied before building.
          Node patches V8, too.
          And Electron patches both Node <em>and</em> Chromium.

          <p>Chromium has a project named depot-tools to wrangle all this.
            and Electron's documentation shows how to do that manually.</p>

          <p>But Sam and Shelly and I recently wrote "electron build-tools",
             Which includes a command-line tool named "e" to handle all the minutia for you.
             <ul>
               <li>It fetches depot-tools and keeps it up-to-date,</li>
               <li>it has sensible defaults for git caching,</li>
               <li>it tries to speed up your build by seeing if it can reuse precompiled pieces from our CI.</li>
               <li>and it does some other helpful things which we'll see later in this talk.</li>
             </ul>
             So, electron's build-tools is what I recommend.
          </p>

          <p>We're going to make it an npm package.
             For today, though, installing it is still pretty easy:</p>
          <p>Let me open a terminal here and I'll show you.</p>
          <p><b>LIVE CODING ctrl-1 to install build tools</b></p>
          <p>As you can see, I don't have `e` yet.</p>
          <p>I am going to put it in my `electron` directory.
             That's path isn't required by any scripts; you can put it anywhere you like.</p>
          <p>If you've used npm apps, you've probably done this before:
             clone the repo from GitHub, cd into it, and npm install.</p>
          <p>Then I add the src directory to my path, and now my command line sees <code>e</code>.</p>
          <p><b>VIDEO ENDS ctrl-0 and show e options</b></p>
          <p>Great! So, let's see what it can do.
            When you're starting out,
            these first four commands are likely to be the first four you'll use:</p>
          <p><code>e init</code> creates a new project file.
             That file remembers where you wanted the source code to be kept,
             and whether to make a test build or a release build.
             And it sets up reasonable defaults for build-time environment variables.</p>
          <p>And these environment variables -- Like I say, `e` tries to "just work",
             so you probably won't be changing these, but just to show you what I'm talking
             about -- you can see what gets injected by running <code>e show env</code>.</>
          <p>Here you see the git caching that I mentioned earlier,
             and sccache here is how we try to speed up your build by reusing pieces from Electron's CI.</p>
             And <code>e show current --filename</code> tells you where your project file lives,
             so you can edit it by hand if you really need to.</p>
          <p><code>sync</code> synchronizes the source code.
             If you haven't checked out the code yet -- such as after running `e init` for the first time -- this will fetch it.
             If you've already checked it out before, this will bring it up-to-date.
             So for example you'll want to sync after checking out a different electron branch
             to make sure the dependencies match.
             Say you've checked out an older version of Electron --
             that older Electron code wants to compile with older versions of Chromium and Node.</p>
          <p>The next two are even more straightforward:
             <code>make</code> makes it and <code>run</code> runs it.</p>
          <p>Lastly, you can combine init, sync, and make all together by calling
             init with the <code>--bootstrap</code> parameter.
             This one-liner will get you an Electron executable from scratch.</p>
          <p><b>VIDEO ctrl-2 for bootstrap</b></p>
          <p>Let's see what that looks like.</p>
          <p>I'm going to run <code>e init</code>... oh actually let's time it to see how long it takes...
             Since we're going to fix a bug in our coding example,
             I'll keep the source in a directory named covalence-bug,
             this will be a testing build,
             I'll name the project file the same as the directory name,
             and I'll bootstrap it.
          <p>So now it's going to pull in and compile those sixty million lines of code.
             no matter how much e tries to soften the blow with caching,
             the first time around it's gonna suck.</p>
          <p>In fact, let's just speed up time a bit here...</p>
          <p>OK. That 'finished' line there at the bottom means it took 24 minutes to download the source.</p>
          <p>And there are 33 thousand pieces to build.</p>
          <p>Let's speed up time again...</p>
          <p>And you can see the bootstrap took about 2200 seconds, about 36 minutes.</p>
          <p>So, hooray! With a bit of patience, or the ability to speed up time, you too can build Electron!</p>
          <p>And because we've done that here, that means we now have code to look at!</p>
          <p>We'll go to the root directory that we specified in <code>e init</code>.</p>
          <p>And by the way, you can use <code>e show</code></p> to ask the current project file for this information, which is handy if you've got a lot of project files or if you're writing shell script helpers to get around.</p>
          <p>For example <code>e show current</code> confirms what we already knew, that covalence-bug is the active project file. And <code>e show root</code> shows what directory we told <code>e init</code> to use.</p>
          <p>So that means you can do something like <code>cd $(e show root)</code></p>
          <p>And when we do that, we get a directory full of who-knows-what.
            android? chromeos? Electron doesn't run on those; what is all this stuff?</p>
          <p>Here's what's going on:
             Out of all those 60 million lines, Electron is only about 70 thousand.
             Less than a tenth of one percent.
             Even Node, with <b>all</b> its dependencies included, is only about 5 million lines.
             Everything else is Chromium. Or its deps.</p>
          <p>Doing thing the Chromium Way has a lot of inertia, life is just
             easier when we use its directory layout and its build structure.
             So what you see here is more or less what you see when building Chromium.
             The one thing that's different is this electron folder here.
             That's where our one tenth of one percent is.
             We'll look at that in a minute,
             But that code will make a little more sense if we run through some Chromium highlights real quick.</p>
          </aside>
        </section>

        <section data-separator-notes="XXX" id="getting-around-the-chromium-codebase">
          <p><b>Electron's Most-Included Chromium Modules</b></p>
          <p style="font-size: 0.6em">See also: <a href="https://cs.chromium.org/" class="url">https://cs.chromium.org/</a>
          <ul>
            <li class="fragment"><span class="filename">base/</span> <span class="secondary_text">general utils, eg: string tokenizing, logging</span></li>
            <li class="fragment"><span class="filename">gin/</span> <span class="secondary_text">convenience utilities for the JavaScript engine v8</span></li>
            <li class="fragment"><span class="filename">blink/</span> <span class="secondary_text">rendering and layout</span></li>
            <li class="fragment"><span class="filename">ui/gfx/</span> <span class="secondary_text">simple graphics classes</span></li>
            <li class="fragment"><span class="filename">ui/views/</span> <span class="secondary_text">framework for using native windows</span></li>
            <li class="fragment"><span class="filename">content/</span> <span class="secondary_text">the core needed for a multi-process sandboxed renderer. (More about this in a moment.)</span></li>
            <li class="fragment"><span class="filename">components/</span> <span class="secondary_text">components that have <span class="filename">content/</span> as the uppermost layer they depend on (eg. printing)</span></li>
            <li class="fragment"><span class="filename">services/</span> <span class="secondary_text">cross-platform management of services</span></li>
          </ul>
          <aside class="notes">
            <p>These are the Chromium Modules that Electron includes the most.</p>
            <p>And I mean 'include' in the C++ sense, which is vaguely like JavaScript's require or import.</p>
            <p>Oh! And if you're following along, try going to cs.chromium.org,
               then opt into the new layout, and click on <code>chromium/src</code>.
               You'll see a sidebar with the same chromium code layout that we just looked at in a terminal
               Chromium's size makes it difficult to search inside an IDE,
               so cs.chromium is your friend.</p>
            <ul>
              <li>The first module you should know about is <code>base</code>.
                  These are general purpose tools that anyone else can use.
                  this is where you'll find your string tokenizers,
                  command-line parsers, logging utils, C++ polyfills, and so on.</li>

              If you want to get familiar with the C++ code, this is the single best starting point.
              It's well-written,
              it's all self-contained,
              and Electron uses it everywhere.

              <li>gin: which is convenience utilities for the javascript engine named v8. 
                  This module is more complex, but might be another good starter candidate
                  if you're wanting to learn more about V8:
              <ul>
                <li> it's only a few thousand lines</li>
                <li> Electron uses it everywhere</li>
              </ul>
              </li>

              <li>blink is chrome's famous rendering and layout engine.
                  And it does a lot of heavy lifting for us.
                  But usually when Electron refers to blink,
                  it's because we need to include the declaration of a blink structure or a blink enumeration.
                  So while understanding Blink is useful, this is not where you'll spend most of your time.</li>

              <li>gfx: here are the fonts, color palettes, and rounded rectangles.
                  This builds on top of the 2D graphics library Skia, which I think is also used by Firefox.</li>

              <li>views (and aura): framework for native UI resources
                  like windows, widgets, textfields, menus.
                  One of Electron's biggest advantages is that it gives you access to native features,
                  so we have a lot of code that builds on top of views.</li>

              <li>next in the chromium stack is content and this is the most important one here.
                  It describes itself as "the core needed for a multi-process sandboxed renderer."
                  Which to me means it's a minimum viable code for a browser and browser only --
                  no extra features like spellcheck, printing, and so on --
                  and someone like Chromium can come along and build a full web browser around it,
                  or someone like Electron can come along and build Electron around it.
                  Content has a public API, and also a reference implementation
                  named "content shell" which renders pages on all platforms.
                  If you're embedding Chromium in an application, content is where you'd start --
                  so let's come back to this module in the next slide.</li>

              <li>components: this is where you'll find most of those 
                  bells and whistles that you won't find in content --
                  they're important, but not intrinsic to content itself.
                  Here's where you'll find printing, translation detection,
                  autofill, bookmarks, you name it.</p>

              <li>finishing the list is services: services reside in their own processes and communicate only via IPC.
                  There's no link-time or run-time exposure, no sharing of global state.
                  Obviously, this has security benefits.
                  It also has pragmatic benefits.
                  For example, audio is a service. If your platform's audio just crashes,
                  Chromium can stop and restart the audio process instead of the entire browser process.</li>
          </aside>
        </section>

        <section id="content-module">
          &nbsp;
          <aside class="notes">
            <p>OK those are Chromium's main modules, at least as seen by Electron.</p>
            <p>Let's finish our Chromium overview by going back into the content module.</p>
            <p>Even just looking at the foldernames at the top of Content,
               there are a few important patterns here that will repeat in the rest of Chromium and Electron.
               These are why I said Electron's code will make more sense after we look at this,</p>
            <p>so I first want to point out these two names, <code>renderer/</code> and </code>browser/</code>.</p>
            <p>The Renderer process renders content.
               In Chromium, a new renderer process is created for each website opened in a new tab --
               so an app can have any number of these processes.</p>
            <p>The browser process, which we sometimes also call the main process,
               is responsible for pretty much everything else, like managing the native user interface as well as disk and network IO.
               There is always exactly one browser process in a content app.</p>.
            <p>And, since Electron is deeply based on this model,
               it has the exact same division of labor between one browser and some number of renderers.
               That's why even Electron's "hello world" app, electron-quick-start, has main.js and renderer.js files.</p>
            <p>Some of the folders here also have patterns that repeat:</p>
            <ul>
              <li><code>utility/</code> is for tasks that can be performed in a utility thread</li>
              <li><code>app/</code> is for the scaffolding where you take all this embeddable stuff
                  and turn it into an actual executable that you can start up and run</li>
              <li><code>common/</code> is for code that's shared between the other folders at this level.</li>
            </ul>
            <p>And if we look in the <code>public/</code> directory,
               This is the public API that's intended for clients like Chromium and Electron to subclass from.
               And in here you see the exact same patterns for how the code is laid out.</p>
            <p>And real quickly I want to point out the <code>shell/</code> directory.
               Again, you see the same patterns.
               As mentioned before, this is kind of a reference implementation of a Content client.
               So sometimes when you're trying to understand a concept in Electron,
               this is good reference to look at.</p>
            <p>OK. Electron's code is all the same patterns so looking at it is going to go quickly.
               but I know that was a lot to take in just now, so before we start,
               as a pallete cleanser,
               so here's a picture of a derpy cat.</p>
          </aside>
        </section>

        <section id="palette-cleanser">
          <img src="assets/derpy-cat.jpg"/>
          <aside class="notes">
            <p>All good? OK, onward!</p> 
          </aside>
        </section>

        <section id="electron-module">
          <aside class="notes">
            <p>Electron has two main folders for its code, <code>lib/</code> and <code>shell</code>.
               Like `content shell`, <code>electron shell/</code> is our subclasses of content's public API.
               Basically, this code is an answer to the question "what would a Content application
               look like it was also made up of node modules and gave you full access to your desktop?"</p>
            <p>And we have <code>lib/</code> which is the javascript layer between electron shell
              and your applications.
              This is where the code lives for all the Electron APIs that your applications import.
              If we can do it in Javascript, it's here. Otherwise, we do it back in electron shell.</p>
            <p><b>navigate through shell and lib directories</b></p>
            <p>And so when we poke around in <code>shell</code> and <code>lib</code>,
               we see the same patterns at play again. Division of labor between
               browser and renderer, a place for shared common code, and so on.</p>
            <p>And since the renderer process renders
               and the browser process handles most of the other things like native ui,
               it'll come as no surprise that the native UI code is in electron/shell/browser/.</p>
          </aside>
        </section>

        <section id="finding-reference-points">
          <p>So if you get a crash in<br/><span class="filename">electron/shell/browser/atom_browser_client</span>:</p>
          <p>
            <ul>
              <li>You know a reference impl is at<br/><span class="filename">content/shell/browser/shell_content_browser_client.cc</span></li>
              <li>You know the parent class is at<br/><span class="filename">content/public/browser/content_browser_client.h</span></li>
            </ul>
          </p>

          <aside class="notes">
            <p>So, putting this together, say you get a crash and your debugger says it's
               in electron/shell/browser/atom_browser_client. And you think to yourself,
               "well I know all those words, but I have no idea what that means."</p>
            <p>from the directory and the filename,
               you already know this is building on top of content.
               so you know where to look for a reference implementation.</p>
            <p>You also know where the parent class is,
               which is usually well-commented.</p>
          </aside>
        </section>

        <section id="finding-the-answer">
          <p>And when you open up<br/><span class="filename">content/public/browser/content_browser_client.h</span>...</p>
          <p><pre><code>// Embedder API (or SPI) for participating in browser
// logic, to be implemented by the client of the content browser.
// See ChromeContentBrowserClient for the principal impl.
// The methods are assumed to be called on the UI thread unless
// otherwise specified. Use this "escape hatch" sparingly,
// to avoid the embedder interface ballooning and becoming
// very specific to Chrome.
class CONTENT_EXPORT ContentBrowserClient {</code></pre></p>
          <p><pre><code>// Allow the embedder to control if an AppCache can be used
// for the given url. This is called on the UI thread.
virtual bool AllowAppCache(const GURL& manifest_url,
                           const GURL& first_party,
                           BrowserContext* context);</code></pre></p>
          <aside class="notes">
            And when you look at the parent class, you learn that BrowserClient is a catch-all
            escape hatch for embedders to fine-tune parts of the browser.
            For example, it lets embedders decide when the app cache can be used.
          </aside>
        </section>

        <section id="the-biggest-class">
          <aside class="notes">
            <p>One final thing about the code.
               I've mentioned a few times how large the codebase is,
               and that scares some people off.
               So I wanted to show you this:</p>
            <p><b>live code <code>find ./ -name "*.cc" | xargs du -s | sort -n</code></b></p>
            <p>Like I said, you're going to find weird code that you don't understand,
              and that's OK because nobody understands all of it and you're in good company.</p>
            <p><em>but</em></p>
            <p>Here we've got the largest source file in electron, atom_api_web_contents.
               And if we open up its class definition,
               we see it's full of things like <code>OpenDevTools()</code> and
               and <code>IsDevToolsOpened()</code>.</p>
            <p>Even though Electron takes time to learn,
               a lot of its code maps directly to concepts that you
               already know if you've ever written an Electron application.</p>
          </aside>
        </section>

        <section id="part-3-taking-action">
          <h2>Coding Example</h2>
          <aside class="notes">
            <p>I joined Electron because I wanted to learn more web tech.
               Before joining, I'd done a lot of code on Linux services
               and Linux desktop apps.
               but I guarantee this room understands writing web apps
               better than I did then.</p>
            <p>But like I said,
               you can do good things on Electron even with only one
               of the skills from that list I gave earlier.</p>
            <p>So with my last five minutes I'm going to show a quick demo of that.
               This is a bug that I fixed early on in Electron,
               and really the only skill I needed to fix it was knowledge
               of a Linux GUI library named GTK.</p>
            <p>And don't worry, you don't need to know GTK to watch this.</p>
            <p>So, the bug report was that on Linux, the `alert()` dialog
               was showing the No Symbol icon.</p>
            <p>Happily, that's super easy to test.</p>
            <p>
            <p><code>
                <ul>
                  <li>cd ~/covalence/electron-quick-start</li>
                  <li>e show current</li>
                  <li>e start</li>
                </ul>
              </code>
            </p>
            <p>Now, I'm pretending for this example I don't know where this code is or how it works -- though if I'd watched this talk, I'd know that the native UI code is in electron/shell/browser.</p>
            <p>But I do know whatever it's using, that icon is getting shown by a call to gtk_widget_show(), because that's how every GTK+ widget is shown.</p>
            <p>So I'll run the same test again inside a debugger and set gtk_widget_show() as a breakpoint.</p>
            <p><code>
                <ul>
                  <li>cd ~/covalence/electron-quick-start</li>
                  <li>e show current</li>
                  <li>e debug</li>
                  <li>r .</li>
                  <li><b>(open up devtools; queue up the alert dialog)</b></li>
                  <li>break gtk_widget_show</li>
                </ul>
              </code>
            </p>
            <p>here's where the dialog is created, and sometimes these use a default icon depending on the dialog type.</p>
            <p>let's go back to the debugger and see what type was passed in.</p>
            <p>looks like that type is atom::MESSAGE_BOX_TYPE_NONE, so that's not the problem.</p>
            <p>Next I see us setting the dialog's image property if a image that's not null is passed in.</p>
            <p>let's go back to the debugger and check.</p>
            <p>walk up the callstack</p>
            <p>icon is a null pointer, so this block of code is never reached, so this isn't the problem either.</p>
            <p>what else calls gtk_widget_show().</p>
            <p>here's a call that only happens when we have a checkbox label... that's not going to be it, but it's very cheap to confirm, we just need to look at the checkbox_label in settings --</p>
            <p>yep, checkbox_label is an empty string.</p>
            <p>so let's keep looking for gtk_widget_show() calls.</p>
            <p>AH now this is promising.</p>
            <p>gtk_widget_show_all() tries to show its whole subtree of widgets, of UI components. </p>
            <p>So maybe what's happening is GtkMessageDialog <i>always</i> has an icon widget, but it's just not shown when the icon property's not set.</p>
            <p>If so, this call here would show that unset icon.</p>
            <p>That would be consistent with the no-icon symbol.</p>
            <p>Let's see what happens if we remove the `_all()` from this.</p>
          </aside>
        </section>

        <section id="thanks">
          <h3>Thanks for listening!</h3>
          <h4>Further reading</h4>
          <p>
            <ul>
              <li><span class="url">https://github.com/electron/build-tools</span></li>
              <li><span class="url">https://electronjs.org/docs/development</span></li>
              <li><span class="url">https://cs.chromium.org/</span></li>
              <li><span class="url">https://www.chromium.org/developers/how-tos/getting-around-the-chrome-source-code</span></li>
            </ul>
          </p>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: false,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'socket.io/socket.io.js', async: true },
          { src: 'plugin/notes-server/client.js', async: true },
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/search/search.js', async: true },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });
    </script>

  </body>
</html>
