<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Electron Hacking for Beginners</title>

    <meta name="description" content="A gentle introduction to finding your way in a very large codebase">
    <meta name="author" content="Charles Kerr">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/night.css" id="theme">
    <style>
      .secondary_text {
        font-size: smaller;
        font-style: italic;
        filter: brightness(66%);
      }
      .filename {
        font: courier;
        font-size: 0.8em;
        color: lime;
        background-color: #222;
        word-break: keep-all;
      }
    </style>

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-markdown data-separator-notes="XXX" id="title-page">
          ## Electron Hacking for Beginners
          &nbsp; 
          &nbsp; 
          A gentle introduction
          to a very large codebase

          XXX
          Hi, I'm Charles Kerr. I'm part of the Electron team at Microsoft.

          Before that I worked for about five years on Ubuntu Linux,

          and before that I wrote most of the BitTorrent app named Transmission.

          So I've done open source for awhile now.
        </section>

        <section id="intent">
          <p>Electron's developer community is high-quality,<br/>but small.</p>
          <p>&nbsp;</p>
          <p>This walkthrough shows how get started on Electron in three sections:</p>
          <p>
            <ol>
              <li>The Tools <span class="secondary_text">(getting and building the code)</span></li>
              <li>The Code <span class="secondary_text">(understanding the code)</span></li>
              <li>Putting It Into Practice <span class="secondary_text">(changing the code)</span></li>
            </ol>
          <aside class="notes">
          <p>In a lot of ways we're a traditional open source project:
             we've got a CoC, governance structure, small team from a
             frustrating number of timezones, etc.</p>

          <p>But <em>unlike</em> a lot of open source projects, at least the
             ones I've worked on, nearly all maintainers are from companies
             that rely on Electron commercially, and nearly all the patches
             come from them.</p>

          <p>And we love our commercial contributors.
             - If your company will give you some tasking time to work on
               Electron, come talk to us.
             - If your company has a beta channel and wants to help us find bugs
               during Electron beta tests, come talk to us.
          </p>

          <p>But still, we don't see that many code volunteers come in
             out of the blue, so this talk is mostly about coding.
             What's the problem?
             Electron is MIT licensed, with no CLA, so it's not the license.
             And there is an ever-growing number of apps using Electron,
             so it's not a lack of interested parties.</p>

          <p>I think what's going on is Electron's got a reputation that its
             code is just too big and scary. This presentation is
             - to show you that it's not as hard as it sounds
             - to show you how to dive in,
             - and importantly, to show you why you might want to dive in.
             I'll do this in three parts:</p>

          <p><b>fragment</b> The tools. Building Electron takes a few tools you've used and a few weird ones you haven't, unless you're paid write web browsers.</p>
          <p><b>fragment</b> The code. Yes, the code is big. Really big. Don't Panic.</p>
          <p><b>fragment</b> Taking action. We'll walk through a real Electron bug and fix it.</p>
          <p>And all this should run about 20-25 minutes.</p>

          </aside>
        </section>

        <section id="whats-in-it-for-me">
          <h3>Why Get Involved?</h3>
          <ol>
            <li class="fragment">Scratch an itch</li>
            <li class="fragment">More first-class desktop apps everywhere</li>
            <li class="fragment">Maybe find a more interersting job?</li>
            <li class="fragment">Use existing skills and learn new ones</li>
          </ol>

          <aside class="notes">
            <p>Why Get Involved?</p>

            <p>Maybe this slide isn't needed since you all chose to watch this talk,
               but I want to cover this quickly since there are a few reasons
               that might not be obvious.</p>

            <p><b>fragment</b>
              Maybe you work on an Electron app and you've found a bug.
               But since there are only a handful of full-time maintainers,
               it never gets prioritized. "Patches welcomed" may be a cliche,
               but it's also true.</p>

            <p><b>fragment</b>
              Maybe you and want more first-class apps to be released for
              your Mac or Linux desktop at the same time as on Windows,
              instead of as an afterthought or not at all.
              Would the Electron apps that you use be running on your desktop
              if their authors had to write three native versions?</p>

            <p><b>fragment</b>
              Maybe you're looking for more interesting full-time work and
              you noticed earlier where I said how many companies are using Electron.</p>

            <p><b>fragment</b>
              Nobody ever talks about this, but this is my favorite one.
              Electron uses JavaScript, C++, Objective C, Typescript, Python.
              It uses Windows native API, Mac native API, GTK+, dbus, posix,
              IPC, Chai, and the list goes on.
              If you know any of those, that's enough to get a foothold
              into the code.
              But what sets Electron apart from a lot of projects is the
              chance to choose from that long shopping list what you'd like
              to learn <em>while using</em> what you already know.</p>
          </aside>
        </section>

        <section data-markdown data-separator-notes="XXX" id="part-1-the-tools">
          #### Part 1 of 3
          ## The Tools

          XXX

          Okay so let's start with the tools.
        </section>

        <section data-markdown data-separator-notes="XXX" id="os-specific-prerequisites">
          ### OS-specific prerequisites

          Instructions at [electronjs.org/docs/](https://electronjs.org/docs/development/build-instructions-gn)

          You've probably done this before.

          * Ex: installing Python 2.7 on macOS with `brew`
          * Ex: installing [Node.js](https://nodejs.org/)

          XXX
          There are platform-specific tools you need to install first.

          These are documented at electronjs.org/docs and I'm going to skip past them because most developers have already used or heard of these and so ... they're not scary.

          For example if you're attending an Electron conference, you've probably installed Node

          And if you're attending an Electron conference and have a Mac, and you've probably installed something using homebrew.

          So moving right along...
        </section>

        <section id="code-what-code">
          <h4>What gets built?</h4>
          Electron, Node, and Chromium
          <p class="fragment">...and Node's dependencies, like brotli, http_parser, llhttp, nghttp2, v8, zlib </p>
          <p class="fragment">...and Chromium's dependencies, like Skia, Views, fido, mojo, libdbus, libaccessability, libpdf, libprotocol, ppapi, libnetwork_service, libgl_wrapper, libbluetooth</class></p>
          <p class="fragment">...and the dependencies' dependencies, like angle, blink, boringssl, breakpad, brotli, cacheinvalidation, ced, cld_3, crashpad, dav1d, dom_distiller, fontconfig, hunspell, iccjpeg, libsecret, srtp, vpx, webm, webp, libxml2, libxslt, libyuv, liblzma, libmodp_b64, openh264, opus, perfetto, pffft, protobuf, re2, sfntly, smhasher, snappy, sqlite, swiftshader, unrar, webrtc, yasm, zlib</p>
          <aside class="notes">
          What gets built?

          Well, Electron <em>is</em> Node plus Chromium plus features.

          We build it all together to ensure everything's compatible.
          For example,
          everything needs to have the same compiler flags.
          We need to ensure that Chromium and Node use the same version of V8.

          *fragment*
          Oh yeah, v8. Node has some dependencies, and we need to build those too.

          *fragment*
          And so does Chromium

          *fragment*
          Oh, and Chromium's dependencies have dependencies.
          If you ever type `npm install`, you might be feeling some deja vu here.
          </aside>
        </section>

        <section data-markdown data-separator-notes="XXX" id="sloccount-all">
          ### So that's a lot of code?

          ```sh
          ~/electron/electron-gn/master/src$ cloc *
          
           20,582,258  C++
            7,477,199  C/C++ Header
            7,116,240  JavaScript
            3,857,228  C
            2,143,884  Python
              245,664  Typescript
           ...

           SUM: 59,751,830
          ```

          **Yes.**
          XXX
          All that adds up to about 60 million lines of code.
          And here I think is where the reputation comes from,
          and why Electron doesn't get as many casual code submissions.

          If you find a bug, where do you even start?
          Even if you just want to build it, where do you start?
          Imagine how many repos you have to clone for that.
          Imagine even tracking the dependencies to know what repos you'd need and keeping them all in sync.
        </section>

        <section id="introducing-the-tools">
          <p><strike>$ npm install</strike></p>
          <p class="fragment">Chromium Depot Tools<br/>(<a href="https://bit.ly/2svgqc5">https://bit.ly/2svgqc5</a>)</p>
          <p class="fragment">Electron Build Tools<br/>(<a href="https://github.com/electron/build-tools">https://github.com/electron/build-tools</a>)</p>
          <aside class="notes">
          Well, you can't just 'npm install' them.
          Chromium pulls from specific commits, not releases, and it also applies patches before building.
          Node does that to V8, too.
          And Electron does that to both Node <em>and</em> Chromium.

          <i>next fragment</i>
          Happily, Chromium has depot_tools, which has meta-checkout and meta-build tools named gclient and gn.
          (gn stands for 'generate ninja', which is like saying 'generate makefiles' for the build tool named ninja)

          <i>next fragment</i>
          And, also happily, Electron has its build-tools repo, which handles basic checkout and build,
          has bells and whistles for swapping between different Electron build sandboxes,
          - setting up git caching correctly,
          - for keeping depot-tools up-to-date,
          - for picking up sccache files from our CI builds to speed up your own build,
          - and so on.
          Electron's documentation describes everything you need to do it manually,
          or you can just let build-tools do most of it for you.
        </section>

        <section data-markdown data-separator-notes="XXX" id="electron-build-tools-overview">
          ### Introducing `e`

          The Electron build tool
          ```sh
          FIXME: this is not readable. Need a better slide to introduce e.
          $ e
          Usage: e <command> [commandArgs...]

          Electron build tool

          Commands:
            init [options] &lt;name&gt;  Create a new build config
            sync [gclientArgs...]  Get or update source code
            make [options]         Build Electron and other things
            run                    Run the Electron executable
            node                   Run the Electron build as if it were a Node.js executable
            debug                  Run the Electron build with a debugger (gdb or lldb)
            use <name>             Use build config <name> when running other `e` commands
            show <subcommand>      Show info about the current build config
            test [specRunnerArgs...]   Run Electron's spec runner
            pr [options]               Open a GitHub URL where you can PR your changes
            patches <basename>         Refresh the patches in $root/src/electron/patches/$basename
          ```

          XXX
          FIXME: write script for this slide
          `e` based off `nvm` which is node version manager
        </section>

        <section data-markdown data-separator-notes="XXX" id="electron-build-tools-demo">
          FIXME: another ugly slide
          * `e init`: set up a new configuration for a specified directory, build type, compile flags, etc.
          * `e sync`: get or update the source code
          * `e make`: build it

          * `e init --bootstrap`: does all three

          * `e init --root=~/electron --bootstrap testing`
            * Creates a new configuration named 'testing' to live in `~/electron`
            * Checks out all the code (this will take a long time)
            * Builds it (this will take even longer)

          XXX
          FIXME: write script for this slide
        </section>

        <section id="building-chromium-is-a-benchmark">
          <img src="assets/chromium-anandtech-benchmark.png"/>
          <aside class="notes">
            <p>And, there's no sugarcoating it, the first time is rough &mdash;
              there's a reason that they made building chromium a benchmark.</p>
            <p>The silver lining is that thanks to a lot of caching,
              after that first time, followup syncs and builds are faster.</p>
            <p>FIXME this needs work</p>
          </aside>
        </section>

        <section id="part-2-the-code">
          <h4>Part 2 of 3</h4>
          <h2>The Code</h2>
          <aside class="notes">
            <p>So now, with a bit of patience, you can build Electron!</p>
            <p>For the next few minutes let's do an exhaustive deep dive into those 60 million lines of code.</p>
          </aside>
        </section>

        <section data-markdown data-separator-notes="XXX" id="finding-the-relevant-code">
          The Chromium modules that Electron uses most
          ```sh
          $ rg --no-filename '^#include "' \
             | grep -v -e shell -e electron \
             | perl -pe "s/\"(\w*?)\/(?:.*)\"/\$1/" \
             | grep -v '\.h"' | sort | uniq -c | sort -nr | head -n8

          972 #include base
          423 #include content
          358 #include ui
          145 #include third_party
          106 #include components
           98 #include gin
           95 #include extensions
           92 #include services
          ```

          Their size
          ```sh
          $ cloc --quiet --json base content ui third_party/skia \
            third_party/blink components gin extensions services \
            | json SUM.code
          11,645,172
          ```

          XXX
          Well, that presentation might go long.
          So instead I've grepped to see which Chromium modules Electron uses most.
          And if we look at the top matches,
          that brings the number down to 11 million.

          Only 11 million! That's nothing.

          By the way, that's a cognitive bias technique called anchoring.
          These 11 million are what matter, but if I'd started the talk
          with that, it would look pretty scary. This way, you know it's
          a cakewalk compared to 60 million &mdash; you've got this.

          So for the next few minutes let's do an exhaustive deep dive into
          those mere 11 million lines of code.

          FIXME: don't panic! this will take about FIXME minutes
        </section>

        <section data-separator-notes="XXX" id="getting-around-the-chromium-codebase">
          <ul>
            <li class="fragment"><span class="filename">base/</span> <span class="secondary_text">general utils, eg: string tokenizing, logging</span></li>
            <li class="fragment"><span class="filename">gin/</span> <span class="secondary_text">convenience utilities for the JavaScript engine v8</span></li>
            <li class="fragment"><span class="filename">blink/</span> <span class="secondary_text">rendering and layout</span></li>
            <li class="fragment"><span class="filename">ui/gfx/</span> <span class="secondary_text">simple graphics classes</span></li>
            <li class="fragment"><span class="filename">ui/views/</span> <span class="secondary_text">framework for using native windows</span></li>
            <li class="fragment"><span class="filename">content/</span> <span class="secondary_text">the core needed for a multi-process sandboxed renderer. (More about this in a moment.)</span></li>
            <li class="fragment"><span class="filename">components/</span> <span class="secondary_text">components that have <span class="filename">content/</span> as the uppermost layer they depend on (eg. printing)</span></li>
            <li class="fragment"><span class="filename">services/</span> <span class="secondary_text">cross-platform management of services</span></li>
          </ul>
          <aside class="notes">
            <ul>
              <li> base: these are general purpose tools that anyone else can use.
                   this is where you'll find your string tokenizers,
                   command-line parsers, logging utils, C++ polyfills, and so on.</li>

              This is a really good starting point if you want to read some code,
              since it's well-written, it's all self-contained,
              and Electron uses it everywhere.

              <li> gin: convenience utilities for v8. 
              Along with base, This would be another good starter:
              <ul>
                <li> it's only a few thousand lines</li>
                <li> Electron uses it everywhere</li>
                <li> and it's a good gateway into v8.</li>
              </ul>
              </li>

              <li> blink is chrome's famous rendering and layout engine.
              And it does a lot of heavy lifting for us.
              But usually when Electron refers to blink,
              it's because some other chrome function uses a blink structure or a blink enumeration.
              So while understanding Blink is useful, you'll spend less time in this module.</li>

              <li> gfx: here are the fonts, color palettes, and rounded rectangles.
              This builds on top of the 2D graphics library Skia, which I think is also used by Firefox.
              FIXME: how to pronounce skia?</li>

              <li> views (and aura): framework for native UI resources
              like windows, widgets, textfields, menus.
              One of Electron's biggest advantages is access to native features,
              we have a lot of code that builds on top of views.</li>

              <li> content: next in the chromium stack is content.
              It's the core needed for a multi-process sandboxed renderer. It has all the web platform features like HTML5.
              It does not include any other browser bells and whistles like extensions or spellchecking or printing.
              It has a basic browser (named content shell) that renders pages on all platforms.
              If you're embedding Chromium in an application, this is where you'd do it.
              To a Chromium developer, Electron probably looks like a content subclass,
              so let's come back to this module in the next slide.</li>

              <li> components: this is where you'll find those in-process
                bells and whistles that are important to a web browser app
                but not intrinsic to the content itself.
                Here's where you'll find printing, translation detection,
                autofill, bookmarks, you name it.</p>

              <li> finishing the list is services: services reside in their own process and communicate only via IPC.
              There's no link-time or run-time exposure, no sharing of global state.
              This has obvious security benefits.
              It also has pragmatic benefits.
              For example, audio is a service. If your platform's audio just bombs out,
              Chromium can kill and restart the service without having to restart the whole browser process.</li>
          </aside>
        </section>

        <section id="content-module">
          <div style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 1em">
            <div><!-- col 1 -->
              <h4>Chromium's<br/>Content Module:<br/>Public API</h4>
              <h5>(<span class="filename">src/content/public/</span>)</h5>
              <ul>
                <li><span class="filename">app/</span></li>
                <li><span class="filename" style="filter: brightness(120%);">browser/</span></li>
                <li><span class="filename">child/</span></li>
                <li><span class="filename">common/</span></li>
                <li><span class="filename" style="filter: brightness(120%);">renderer/</span></li>
                <li><span class="filename">test/</span></li>
              </ul>
            </div>
            <div><!-- col 2 -->
              <h4>Chromium's<br/>Content Module:<br/>Content Shell</h4>
              <h5>(<span class="filename">src/content/shell/</span>)</h5>
              <ul>
                <li><span class="filename">android/</span></li>
                <li><span class="filename">browser/</span></li>
                <li><span class="filename">common/</span></li>
                <li><span class="filename">gpu/</span></li>
                <li><span class="filename">renderer/</span></li>
                <li><span class="filename">utility/</span></li>
              </ul>
            </div>
          </div>
          <aside class="notes">
            <p>
            Now back to Chromium's content module.
            Content defines the interfaces for a bare-bones multiprocess browser.
            Like I said, if you're embedding Chromium, this is where you start.</p>
            </p>

            <p>
            Here, The left column shows the modules in content's public API.
            Most of Electron's C++ code is in service of subclasses these.
            </p>

            <p>
            And if you've wrtten even Hello World in Electron,
            the separation of concerns between browser and renderer
            will already look familiar. This is where that separation
            in Electron comes from.
            </p>

            <p>
            As mentioned before, content has its own basic implementation called "content shell"
            and here on the right you can see its modules.
            So a lot of the time you can use this as reference code
            and see what pieces Electron re-used and what it
            couldn't reuse due to its own requirements.
            </p>

          </aside>
        </section>

        <section id="electron-modules">
          <div style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 1em">
            <!--<div style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 1em">-->
            <div><!-- col 1 -->
              <h4>Electron's JavaScript<br/>Modules</h4>
              <h5>(<span class="filename">src/electron/lib/</span>)</h5>
              <ul>
                <li><span class="filename">browser/</span></li>
                <li><span class="filename">common/</span></li>
                <li><span class="filename">content_script/</span></li>
                <li><span class="filename">isolated_renderer/</span></li>
                <li><span class="filename">renderer/</span></li>
                <li><span class="filename">sandboxed_renderer/</span></li>
                <li><span class="filename">worker/</span></li>
              </ul>
            </div>
            <div><!-- col 2 -->
              <h4>Electron's C++<br/>Modules</h4>
              <h5>(<span class="filename">src/electron/shell/</span>)</h5>
              <ul>
                <li><span class="filename">app/</span></li>
                <li><span class="filename">browser/</span></li>
                <li><span class="filename">common/</span></li>
                <li><span class="filename">renderer/</span></li>
                <li><span class="filename">utility/</span></li>
              </ul>
            </div>
          </div>
          <aside class="notes">
            <p>When you look at Electron's code,
              you'll see the same ideas in play.</p>
            <p>On the left here you'll see the javascript and typescript modules.
               This is the user-facing code that Electron applications import or require.</p>
            <p>On the right is the C++ layer that goes between lib and Chromium's content module.
               This is where we subclass from content's public APIs,
               where platform native features go,
               and where we tie into Node.</p>
            <p>In both of these columns,
               app, browser, common, renderer, and utility
               all carry the same meanings as in chromium's content module.</p>
          </aside>
        </section>

        <section id="finding-reference-points">
          <p>So if you need context on <span class="filename">electron/shell/browser/atom_browser_client</span>:
            <ul>
              <li>You know a reference impl is at <span class="filename">content/shell/browser/shell_content_browser_client.cc</span></li>
              <li>You know the parent class is at <span class="filename">content/public/browser/content_browser_client.h</span></li>
            </ul>
          </p>

          <aside class="notes">
            <p>So, putting this together, say you get a crash and your debugger says it's
               in electron/shell/browser/atom_browser_client. And you think to yourself,
               "well I know all those words, but I have no idea what that means."</p>
            <p>from the directory and the filename,
               you already know this is building on top of content.
               so you know where to look for a reference implementation.</p>
            <p>You also know where the parent class is,
               which is usually well-commented.</p>
          </aside>
        </section>

        <section id="finding-the-answer">
          <p>And when you open up <span class="filename">content/public/browser/content_browser_client.h</span>...</p>
          <p><pre><code>// Embedder API (or SPI) for participating in browser
// logic, to be implemented by the client of the content browser.
// See ChromeContentBrowserClient for the principal impl.
// The methods are assumed to be called on the UI thread unless
// otherwise specified. Use this "escape hatch" sparingly,
// to avoid the embedder interface ballooning and becoming
// very specific to Chrome.
class CONTENT_EXPORT ContentBrowserClient {</code></pre></p>
          <p><pre><code>// Allow the embedder to control if an AppCache can be used
// for the given url. This is called on the UI thread.
virtual bool AllowAppCache(const GURL& manifest_url,
                           const GURL& first_party,
                           BrowserContext* context);</code></pre></p>
          <aside class="notes">
            And when you look at the parent class, you learn that BrowserClient is a catch-all
            escape hatch for embedders to fine-tune parts of the browser.
            For example, it lets embedders decide when the app cache can be used.
          </aside>
        </section>

        <section data-markdown data-separator-notes="XXX" id="the-biggest-class">
          FIXME: is this content needed?
          FIXME: there is no flow from previous slide
          FIXME: this slide is even uglier than the others

          **Excerpt from Electron's largest class, atom::api::WebContents**
          ```cpp
            void LoadURL(const GURL& url, const mate::Dictionary& opts);
            base::string16 GetTitle() const;
            bool IsLoading() const;
            void Stop();
            void ReloadIgnoringCache();
            void GoBack();
            void GoForward();
            bool IsCrashed() const;
            void SetUserAgent(const std::string& user_agent);
            std::string GetUserAgent();
            void InsertCSS(const std::string& css);
            void OpenDevTools(mate::Arguments* args);
          ```

          XXX
          This <i>is</i> the largest class we've got.
          And, while the size of the whole project can be overwhelming,
          the individual pieces aren't actually that scary.

          To be clear: no, I'm not saying Electron is easy.
          Some of it is, but a lot of it isn't.

          But if you've written Electron apps,
          if you've used `win.loadURL()` or `win.getTitle()`,
          you already see the big picture, and that can be your guide
          when you're reading and learning the littler pictures.
        </section>

        <section id="crazy-wall">
          <img src="assets/my-brain-is-full.jpg"/>
          <aside class="notes">
            <p>OK that's probably enough theory.</p>
            <p>You all now know how to get and build one of the world's largest open source codebases.</p>
            <p>You have an idea of how 11 million puzzle pieces fit together.</p>
            <p>And what you don't know, you know where to start looking to find out.</p>
            <p>Let's do something with all this knowledge.</p>
          </aside>
        </section>

        <section id="part-3-taking-action">
          <h4>Part 3 of 3</h4>
          <h2>Taking Action</h2>
          <aside class="notes">
            <p>OK so remember back to the beginning when I said if you've got chai,
               or IPC, or Windows, or Linux, or XYZ experience,
               that can give you a foothold.</p>
            <p>I also said that before Electron, I worked for Canonical on its
               Linux desktop. So here's a bug I fixed very early on using only
               my knowledge of Linux's GUI library named GTK+.</p>
            <p>You don't need any GTK+ experience to follow along.
               My point here is that, whichever of that shopping list of skills you have,
               you can do good without memorizing 60 million lines of code first.</p>
          </aside>
        </section>

        <section id="debugging">
          <img src="assets/bug-report.png"/>
          <aside class="notes">
            <p>The bug report's screenshot says it all: on Linux, the `alert()` dialog is showing a No Symbol icon.</p>
            <p>This should be easy to test.</p>
          </aside>
        </section>

        <section id="final-thoughts-on-code">
          <h3>Final thoughts on the codebase</h3>
          <ul>
          <li class="fragment">Electron is a good project for someone who knows X and wants to learn Y</li>
          <li class="fragment">You already understand more than you think</li>
          <li class="fragment">Don't Panic</li>
          </ul>
          <aside class="notes">
          <p>As said in the last slide, <b>(fragment)</b> you understand more than you think.</p>
          <p><b>(fragment)</b> When I started contributing to Electron, I'd never touched Node. So for me it was both unfamiliar *and* alien, and I stressed over that a lot.</p>
          <p>The thing to understand is you've got millions of lines of code -- <b>everyone</b> is lost to some degree.</p>
          <p>When I realized it's OK to be a <i>little</i> lost, that freed me up to stress about it less and focus and learn faster.</p>
          <p><b>(fragment)</b> As an aside, Chromium has a lot of solid engineering. [read fragment aloud here] The Chromium directory named `base/` holds general-use tools, mostly self-contained, so it's not a bad place to start. You'll find Chromium's string manipulation, memory management, callback binding, and so on.</p>
        </section>

        <section data-markdown data-separator-notes="XXX" data-background-video="assets/bugfix.webm" data-background-color="#000000">
          XXX
          make sure we have a fresh build

          let's run electron-quick-start

          open devtools

          and pull up an alert dialog.

          sure enough.

          Now, I'm pretending for this example I don't know whether Electron is using a GtkMessageDialog, a GtkDialog, or not using those at all but instead creating a custom GtkWindow.

          But I do know whatever it's using, that icon is getting shown by a call to gtk_widget_show(), because that's what every GTK+ widget uses, no matter what type of class is aggregating it.

          So I'll run the same test again inside a debugger and set gtk_widget_show() as a breakpoint.

          open devtools again...

          set the breakpoint... gdb is kind of slow.

          the alert again...

          cool. let's see where it's coming from.

          ok this noise here is C++'s version of the green terminal windows in the matrix. You get used to it.

          first thing I see here is it's in atom/browser/ui/message_box_gtk, which means it's likely our bug.

          I see an argument named 'icon' of type imageskia, so maybe someone is passing in a broken icon.

          let's open up atom/browser/ui/message_box_gtk line 49 and take a look.

          here's where the dialog is created, and sometimes these use a default icon depending on the dialog type.

          let's go back to the debugger and see what type was passed in.

          looks like that type is atom::MESSAGE_BOX_TYPE_NONE, so that's not the problem.

          Next I see us setting the dialog's image property if that imageskia isn't null.

          let's go back to the debugger and check.

          walk up the callstack

          and icon.isNull() is _true_, so this block of code is never reached, so this isn't the problem either.

          what else calls gtk_widget_show().

          here's a call that only happens when we have a checkbox label... that's not going to be it, but just for fun let's ask the debugger what checkbox_label is --

          yep, checkbox_label is an empty string.

          so let's keep looking for gtk_widget_show() calls.

          AH now this is promising.

          gtk_widget_show_all() tries to show its whole subtree of widgets, of UI components. 

          So maybe what's happening is GtkMessageDialog _always_ has an icon widget, but it's just not shown when the icon property's not set.

          If so, this call here would show that unset icon.

          That would be consistent with the no-icon symbol.

          Let's see what happens if we remove the `_all()` from this.

          rebuild

          restart the process

          pop up devools

          show an alert

          there we go!

          We got it.

          And although I knew some GTK+ to solve this bug, this one didn't really take any Electron.

          (fast transition to)
        </section>

        <section id="conclusions">
          <h3>What Have We Learned?</h3>
          <li class="fragment">Whether you know Electron, GTK+, Chromium, Node.js, Windows, JS, C++, Obj-C, Carbon, Linux, or Docker... those are <i>all</i> skills that you can use on Electron.</li>
        </section>

        <section data-markdown data-separator-notes="XXX" id="thanks">
          ### Thanks for listening!

          #### Further reading
          * https://electronjs.org/docs/development

          * https://cs.chromium.org/

          * https://www.chromium.org/developers/how-tos/getting-around-the-chrome-source-code

          * https://www.patreon.com/sindresorhus
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: false,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/search/search.js', async: true },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });
    </script>

  </body>
</html>
