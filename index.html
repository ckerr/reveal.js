<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Electron Hacking for Beginners</title>

    <meta name="description" content="A gentle introduction to a very large codebase">
    <meta name="author" content="Charles Kerr">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/night.css" id="theme">
    <style>
      .secondary_text {
        font-size: smaller;
        font-style: italic;
        filter: brightness(66%);
      }
      .reveal section .why_image {
        background-color: transparent;
        border: none;
        height: 200px;
        width: 150px;
      }
      .filename {
        font: courier;
        font-size: 0.8em;
        color: lime;
        background-color: #222;
        word-break: keep-all;
      }
      .url {
        color: #0f0;
        text-decoration: underline;
      }
    </style>

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section id="title-page">
          <h2>Electron Hacking for Beginners</h2>
          <p>A gentle introduction to a very large codebase</p>
          <p>&nbsp;</p>
          <p>Charles Kerr<br/><span style="font-size: smaller">Microsoft's Electron Team</span></p>
          <aside class="notes">
            <p>Hi, I'm Charles Kerr. I'm part of the Electron team at Microsoft. There, I'm one of the Electron maintainers.</p>
            <p>And today I'm going to talk about why you should get involved with Electron's development, too.</p>
          </aside>
        </section>

        <section id="topics">
          <h3>Getting Involved!</h3>
          <ol>
            <li>Why?</li>
            <li>How?
              <ul>
                <li>Getting the code</li>
                <li>Building the code</li>
                <li>Understanding the code</li>
              </ul>
            </li>
            <li>Live coding demo</li>
          </ol>

          <aside class="notes">
          <p>So we'll go over why you would want to do that,</p>
          <p>how to do that,</p>
          <p> -- including the mechanics of getting and building the code, and importantly, finding your way around the code --</p>
          <p>and we'll finish by putting it into action with a short coding example.</p>
          <p>This talk is about coding, but if you're not a coder, there are other ways to help.</p>
          <p>If you're bilingual, there is a project to translate our documentation.</p>
          <p>If you're in QA, we have a group of QA people from other Electron apps
             and you can come and learn from them.</p>
          <p>If you have an app with a beta channel and you want to help us find bugs in
             Electron's betas, come talk to us.</p>
          </aside>
        </section>

        <section id="why-get-involved">
          <h3>Why Get Involved?</h3>
          <div style="display: grid; grid-template-columns: 3fr 1fr 1fr 1fr 1fr; grid-column-gap: 0.5em">
            <div class="fragment"><img class="why_image" src="assets/tux.png"> <img class="why_image" src="assets/mac-os.png"></div>
            <div class="fragment"><img class="why_image" src="assets/Light-bulb-icon.png"/></div>
            <div class="fragment"><img class="why_image" src="assets/bag-of-money.png"/></div>
            <div class="fragment"><img class="why_image" style="height: 150px; padding-top: 33px" src="assets/happy.png"/></div>
            <div class="fragment"><img class="why_image" src="assets/infinity-gauntlet.png"/></div>
          </div>
          <aside class="notes">
            <p>So, why get involved?</p>
            <p><b>FRAGMENT (show tux)</b></p>
            <p>First, maybe you're a developer who uses more than one desktop and you like it when apps run on all of them.</p>
            <p>Do you run anything that wouldn't be on your desktop if electron didn't exist?</p>

            <p><b>FRAGMENT (show lightbulb)</b></p>
            <p>Maybe you want to put your skills to use while also learning new ones.
               Electron uses a <em>lot</em> of languages and tools.
               <ol>
                 <li>JavaScript</li>
                 <li>TypeScript</li>
                 <li>C++</li>
                 <li>Python</li>
                 <li>Objective C.</li>
                 <li>We use Mac APIs</li>
                 <li>Windows APIs</li>
                 <li>we use posix, GTK+, and dbus on Linux</li>
                 <li>our tests use chai</li>
                 <li>our CI uses docker</li>
                 <li>...and so many more. I literally could not name them all.</li>
               </ol></p>
            <p>And maybe that sounds overwhelming;
               but if you get just one thing from this talk, I want you to understand
               that <b>you can</b> do good things on Electron even if you only know one of those skills.
               <em>Nobody</em> understands the whole list, so you're in good company.
               And if you do know one or two of those things and want to learn more,
               Electron has so many more opportunities than your average project.</p>
            <p>Electron's code is big and isn't always easy, but it often it is.
               <b>You can</b> do good things on Electron even if you are just starting out.</p>

            <p><b>FRAGMENT (show bag of money)</b></p>
            <p>Maybe you're looking for better-paying work.</p>
            <p>There are a <b>lot</b> of apps shipping on Electron,
               but if Application X hits some weird issue,
               there aren't that many people who know how
               to dig deep into Electron's source and fix it.</p>
            <p>I heard the manager on one Electron app say that
               another team could take their Electron person
               over that manager's dead body.</p>

            <p><b>FRAGMENT (show smiley)</b></p>
            <p>Related to the last two, maybe you're looking for more <em>interesting</em> work.</p>
            <p>When it comes to learning new things at your own speed,
               Electron is an evergreen project.
               That list of skills I just rattled off means that you can hack on Electron
               for a <b>long</b> time without stagnating, without getting bored.</p>

            <p><b>FRAGMENT (infinity gauntlet)</b></p>
            <p>Lastly, power. Influence.</p>
            <p>Electron is a community-based project. We've got a governance structure,
               a code of conduct, maintainers around the world -- but there's only about
               a dozen of us full-time.</p>
            <p>Anyone in this room, if they wanted to invest the time,
               can go from having no say to having a very prominent say.</p>
            <p>As long as it's not to the detriment of others, we're very flexible</p>

          </aside>
        </section>

        <section id="code-what-code">
          <h4>What code do I need?</h4>
          Electron, Node, and Chromium
          <p class="fragment" sytle="font-size: 0.9em">...and Node's dependencies, like brotli, http_parser, llhttp, nghttp2, v8, zlib </p>
          <p class="fragment" style="font-size: 0.8em">...and Chromium's dependencies, like Skia, Views, fido, mojo, libdbus, libaccessability, libpdf, libprotocol, ppapi, libnetwork_service, libgl_wrapper, libbluetooth</class></p>
          <p class="fragment" style="font-size: 0.6em">...and the dependencies' dependencies, like angle, blink, boringssl, breakpad, brotli, cacheinvalidation, ced, cld_3, crashpad, dav1d, dom_distiller, fontconfig, hunspell, iccjpeg, libsecret, srtp, vpx, webm, webp, libxml2, libxslt, libyuv, liblzma, libmodp_b64, openh264, opus, perfetto, pffft, protobuf, re2, sfntly, smhasher, snappy, sqlite, swiftshader, unrar, webrtc, yasm, zlib</p>
          <aside class="notes">
            <p>Alright, so if any of that sounded interesting,
               the next thing to do is get the code.</p>

            <p>So, what do you need to get? Well as you know, Electron is Node plus Chromium plus features.</p>

            <p>And we compile all their sources to ensure everything's compatible.
               For example,
               everything needs to have the same compiler flags.
               And we also need to ensure that Chromium and Node use the same version of the javascript engine named V8.</p>

            <p><b>fragment</b>
            Oh yeah, v8. Node has some dependencies, and we need to build those too.</p>

            <p><b>fragment</b>
            And so does Chromium</p>

            <p><b>fragment</b>
            Oh, and Chromium's dependencies have dependencies.
            When you add everything up, it's about 60 million LOC.
            </p>
          </aside>
        </section>

        <section id="introducing-electron-build-tools">
          <p style="color: #f00; text-decoration: line-through;">$ brew install</p>
          <p style="color: #f00; text-decoration: line-through;">$ npm install</p>
          <p style="color: #f00; text-decoration: line-through;">$ sudo apt install</p>
          <p class="url">https://github.com/electron/build-tools</p>
          <aside class="notes">
          And for added fun, you can't just install them.
          Chromium's dependencies aren't specified by their version numbers; they use specific commit hashes.
          And Chromium has custom patches for its dependencies --
          so those have to be applied before building.
          Node patches V8, too.
          And Electron patches both Node <em>and</em> Chromium.

          <p>Chromium has a project named depot-tools to wrangle all this.
            and Electron's documentation shows how to do that manually.</p>

          <p>But Sam and Shelly and I recently wrote "electron build-tools",
             Which includes a command-line tool named "e" to handle all the minutia for you.
             <ul>
               <li>It fetches depot-tools and keeps it up-to-date,</li>
               <li>it has sensible defaults for git caching,</li>
               <li>by default it tries to speed up your build by seeing if it can reuse precompiled pieces made by our CI.</li>
               <li>It does all this while trying to "Just work" right out-of-the-box,</li>
               <li>and it does some other helpful things which we'll see later in this talk.</li>
             </ul>
             So, electron's build-tools is what I recommend.
          </p>

          <p>We're going to make it an npm package.
             For today, though, installing it is still pretty easy.</p>
          <p>Let me open a terminal here and I'll show you.</p>
          <p><b>LIVE CODING ctrl-1 to install build tools</b></p>
          <p>As you can see, I don't have `e` yet.</p>
          <p>I am going to put it in my `electron` directory.
             That's path isn't required by any scripts; you can put it anywhere you like.</p>
          <p>If you've used npm apps, you've probably done this before:
             clone the repo from GitHub, cd into it, and npm install.</p>
          <p>Then I add the src directory to my path, and now my command line sees <code>e</code>.</p>
          <p><b>VIDEO ENDS ctrl-0 and show e options</b></p>
          <p>Great! So, let's see what it can do.
            When you're starting out,
            these first four commands are likely to be the first four you'll use:</p>
          <p><code>e init</code> creates a new project file.
             That file remembers where you wanted the source code to be kept,
             and whether to make a test build or a release build.
             And it sets up reasonable defaults for build-time environment variables.</p>
          <p>And these environment variables -- Like I say, `e` tries to "just work",
             so you probably won't be changing these, but just to show you what I'm talking
             about -- you can see what gets injected by running <code>e show env</code>.</>
          <p>Here you see the git caching that I mentioned earlier,
             and sccache here is how we try to speed up your build by reusing pieces from Electron's CI.</p>
             And <code>e show current --filename</code> tells you where your project file lives,
             so you can edit it by hand if you really need to.</p>
          <p><code>sync</code> synchronizes the source code.
             If you haven't checked out the code yet -- such as after running `e init` for the first time -- this will fetch it.
             If you've already checked it out before, this will bring it up-to-date.
             So for example you'll want to sync after checking out a different electron branch
             to make sure the dependencies match.
             Say you've checked out an older version of Electron --
             that older Electron code wants to compile with older versions of Chromium and Node.</p>
          <p>The next two are even more straightforward:
             <code>make</code> makes it and <code>run</code> runs it.</p>
          <p>Lastly, you can combine init, sync, and make all together by calling
             init with the <code>--bootstrap</code> parameter.
             This one-liner will get you an Electron executable from scratch.</p>
          <p><b>VIDEO ctrl-2 for bootstrap</b></p>
          <p>Let's see what that looks like.</p>
          <p>I'm going to run <code>e init</code>... oh actually let's time it to see how long it takes...
             Since we're going to fix a bug in our coding example,
             I'll keep the source in a directory named covalence-bug,
             this will be a testing build,
             I'll name the project file the same as the directory name,
             and I'll bootstrap it.
          <p>So now it's going to pull in and compile those sixty million lines of code.
             And that's about as slow as it sounds like it would be,
             no matter how much e tries to soften the blow.
             There's a reason anandtech has a hardware benchmark that just lists Chromium build times.</p>
          <p>In fact, let's just speed up time a bit here...</p>
          <p>OK. That 'finished' line there at the bottom means it took 24 minutes to download the source.</p>
          <p>And there are 33 thousand pieces to build.</p>
          <p>Let's speed up time again...</p>
          <p>And you can see the bootstrap took about 2200 seconds, about 36 minutes.</p>
          <p>So, hooray! With a bit of patience, or the ability to speed up time, you too can build Electron!</p>
          <p>And because we've done that here, that means we now have code to look at!</p>
          <p>We'll go to the root directory that we specified in <code>e init</code>.</p>
          <p>And by the way, you can use <code>e show</code></p> to ask the current project file for this information, which is handy if you've got a lot of project files or if you're writing shell script helpers to get around.</p>
          <p>For example <code>e show current</code> confirms what we already knew, that covalence-bug is the active project file. And <code>e show root</code> shows what directory we told <code>e init</code> to use.</p>
          <p>So that means you can do something like <code>cd $(e show root)</code></p>
          <p>And when we do that, we get a directory full of who-knows-what.
            android? chromeos? Electron doesn't run on those; what is all this stuff?</p>
          <p>Here's what's going on:
             Out of all those 60 million lines, Electron is only about 70 thousand.
             Less than a tenth of one percent.
             Even Node, with <b>all</b> its dependencies included, is only about 5 million lines.
             Everything else is Chromium. Or its deps.</p>
          <p>Doing thing the Chromium Way has a lot of inertia, life is just
             easier when we use its directory layout and its build structure.
             So what you see here is more or less what you see when building Chromium.
             The one thing that's different is this electron folder here.
             That's where our one tenth of one percent is.
             We'll look at that in a minute,
             But that code will make a little more sense if we run through some Chromium highlights real quick.</p>
          </aside>
        </section>

        <section data-separator-notes="XXX" id="getting-around-the-chromium-codebase">
          <p><b>Electron's Most-Included Chromium Modules</b></p>
          <p style="font-size: 0.6em">See also: <a href="https://cs.chromium.org/" class="url">https://cs.chromium.org/</a>
          <ul>
            <li class="fragment"><span class="filename">base/</span> <span class="secondary_text">general utils, eg: string tokenizing, logging</span></li>
            <li class="fragment"><span class="filename">gin/</span> <span class="secondary_text">convenience utilities for the JavaScript engine v8</span></li>
            <li class="fragment"><span class="filename">blink/</span> <span class="secondary_text">rendering and layout</span></li>
            <li class="fragment"><span class="filename">ui/gfx/</span> <span class="secondary_text">simple graphics classes</span></li>
            <li class="fragment"><span class="filename">ui/views/</span> <span class="secondary_text">framework for using native windows</span></li>
            <li class="fragment"><span class="filename">content/</span> <span class="secondary_text">the core needed for a multi-process sandboxed renderer. (More about this in a moment.)</span></li>
            <li class="fragment"><span class="filename">components/</span> <span class="secondary_text">components that have <span class="filename">content/</span> as the uppermost layer they depend on (eg. printing)</span></li>
            <li class="fragment"><span class="filename">services/</span> <span class="secondary_text">cross-platform management of services</span></li>
          </ul>
          <aside class="notes">
            <p>These are the Chromium Modules that Electron includes the most.</p>
            <p>And I mean 'include' in the C++ sense, which is vaguely like JavaScript's require or import.</p>
            <p>Oh! And if you're following along, try going to cs.chromium.org,
               then opt into the new layout, and click on <code>chromium/src</code>.
               You'll see a sidebar with the same chromium code layout that we just looked at in a terminal
               Chromium's size makes it difficult to search inside an IDE,
               so cs.chromium is your friend.</p>
            <ul>
              <li>The first module you should know about is <code>base</code>.
                  These are general purpose tools that anyone else can use.
                  this is where you'll find your string tokenizers,
                  command-line parsers, logging utils, C++ polyfills, and so on.</li>

              If you want to get familiar with the C++ code, this is the single best starting point.
              It's well-written,
              it's all self-contained,
              and Electron uses it everywhere.

              <li>gin: which is convenience utilities for the javascript engine named v8. 
                  This module is more complex, but might be another good starter candidate
                  if you're wanting to learn more about V8:
              <ul>
                <li> it's only a few thousand lines</li>
                <li> Electron uses it everywhere</li>
              </ul>
              </li>

              <li>blink is chrome's famous rendering and layout engine.
                  And it does a lot of heavy lifting for us.
                  But usually when Electron refers to blink,
                  it's because we need to include the declaration of a blink structure or a blink enumeration.
                  So while understanding Blink is useful, this is not where you'll spend most of your time.</li>

              <li>gfx: here are the fonts, color palettes, and rounded rectangles.
                  This builds on top of the 2D graphics library Skia, which I think is also used by Firefox.</li>

              <li>views (and aura): framework for native UI resources
                  like windows, widgets, textfields, menus.
                  One of Electron's biggest advantages is that it gives you access to native features,
                  so we have a lot of code that builds on top of views.</li>

              <li>next in the chromium stack is content and this is the most important one here.
                  It describes itself as "the core needed for a multi-process sandboxed renderer."
                  Which to me means it's a minimum viable code for a browser and browser only --
                  no extra features like spellcheck, printing, and so on --
                  and someone like Chromium can come along and build a full web browser around it,
                  or someone like Electron can come along and build Electron around it.
                  Content has a public API, and also a reference implementation
                  named "content shell" which renders pages on all platforms.
                  If you're embedding Chromium in an application, content is where you'd start --
                  so let's come back to this module in the next slide.</li>

              <li>components: this is where you'll find most of those 
                  bells and whistles that you won't find in content --
                  they're important, but not intrinsic to content itself.
                  Here's where you'll find printing, translation detection,
                  autofill, bookmarks, you name it.</p>

              <li>finishing the list is services: services reside in their own processes and communicate only via IPC.
                  There's no link-time or run-time exposure, no sharing of global state.
                  Obviously, this has security benefits.
                  It also has pragmatic benefits.
                  For example, audio is a service. If your platform's audio just crashes,
                  Chromium can stop and restart the audio process instead of the entire browser process.</li>
          </aside>
        </section>

        <section id="content-module">
          &nbsp;
          <aside class="notes">
            <p>OK those are Chromium's main modules, at least as seen by Electron.</p>
            <p>Let's finish our Chromium overview by going back into the content module.</p>
            <p>Even just looking at the foldernames at the top of Content,
               there are a few important patterns here that will repeat in the rest of Chromium and Electron.
               These are why I said Electron's code will make more sense after we look at this,</p>
            <p>so I first want to point out these two names, <code>renderer/</code> and </code>browser/</code>.</p>
            <p>The Renderer process renders content.
               In Chromium, a new renderer process is created for each website opened in a new tab --
               so an app can have any number of these processes.</p>
            <p>The browser process, which we sometimes also call the main process,
               is responsible for pretty much everything else, like managing the native user interface as well as disk and network IO.
               There is always exactly one browser process in a content app.</p>.
            <p>And, since Electron is deeply based on this model,
               it has the exact same division of labor between one browser and some number of renderers.
               That's why even Electron's "hello world" app, electron-quick-start, has main.js and renderer.js files.</p>
            <p>Some of the folders here also have patterns that repeat:</p>
            <ul>
              <li><code>utility/</code> is for tasks that can be performed in a utility thread</li>
              <li><code>app/</code> is for the scaffolding where you take all this embeddable stuff
                  and turn it into an actual executable that you can start up and run</li>
              <li><code>common/</code> is for code that's shared between the other folders at this level.</li>
            </ul>
            <p>Next, we go into the <code>public/</code> directory.
               This is the public API that's intended for clients -- like Chromium and Electron -- to subclass from.
               And in here you see the exact same patterns for how the code is laid out.</p>
            <p>The last thing before we move on to Electron is the <code>shell/</code> directory.
               Again, you see the same patterns.
               As mentioned before, this is kind of a reference implementation of a Content client.
               So sometimes when you're trying to understand a concept, this is good reference to look at
               whether or not Electron uses some particular part of it.</p>
          </aside>
        </section>

        <section id="palette-cleanser">
          <img src="assets/derpy-cat.jpg"/>
          <aside class="notes">
            <p>OK. Electron's code is going to go a lot faster,
               but I know that was a lot to take in, so before we start,
               as a pallete cleanser,
               so here's a picture of a derpy cat.</p>
            <p>All good? OK, onward we go!</p> 
          </aside>
        </section>

        <section id="electron-module">
          <aside class="notes">
            <p>Electron has two main folders for its code, <code>lib/</code> and <code>shell</code>.
               Like content, <code>shell/</code> is our subclasses of the public content API.
               Basically, this code is an answer to the question "what would a content module application
               look like it was also made up of node modules and gave you full native desktop access?"</p>
            <p>And we have <code>lib/</code> which is the javascript layer between shell and your applications.
              This is where the code lives for all the Electron APIs that your applications import.
              If we can do it in Javascript, it's here. Otherwise, we do it back in electron shell.</p>
            <p><b>navigate through shell and lib directories</b></p>
            <p>And so when we poke around in <code>shell</code> and <code>lib</code>,
               we see the same patterns at play again. Division of labor between
               browser and renderer, a place for shared common code, and so on.</p>
          </aside>
        </section>

        <section id="finding-reference-points">
          <p>So if you get a crash in<br/><span class="filename">electron/shell/browser/atom_browser_client</span>:</p>
          <p>
            <ul>
              <li>You know a reference impl is at<br/><span class="filename">content/shell/browser/shell_content_browser_client.cc</span></li>
              <li>You know the parent class is at<br/><span class="filename">content/public/browser/content_browser_client.h</span></li>
            </ul>
          </p>

          <aside class="notes">
            <p>So, putting this together, say you get a crash and your debugger says it's
               in electron/shell/browser/atom_browser_client. And you think to yourself,
               "well I know all those words, but I have no idea what that means."</p>
            <p>from the directory and the filename,
               you already know this is building on top of content.
               so you know where to look for a reference implementation.</p>
            <p>You also know where the parent class is,
               which is usually well-commented.</p>
          </aside>
        </section>

        <section id="finding-the-answer">
          <p>And when you open up<br/><span class="filename">content/public/browser/content_browser_client.h</span>...</p>
          <p><pre><code>// Embedder API (or SPI) for participating in browser
// logic, to be implemented by the client of the content browser.
// See ChromeContentBrowserClient for the principal impl.
// The methods are assumed to be called on the UI thread unless
// otherwise specified. Use this "escape hatch" sparingly,
// to avoid the embedder interface ballooning and becoming
// very specific to Chrome.
class CONTENT_EXPORT ContentBrowserClient {</code></pre></p>
          <p><pre><code>// Allow the embedder to control if an AppCache can be used
// for the given url. This is called on the UI thread.
virtual bool AllowAppCache(const GURL& manifest_url,
                           const GURL& first_party,
                           BrowserContext* context);</code></pre></p>
          <aside class="notes">
            And when you look at the parent class, you learn that BrowserClient is a catch-all
            escape hatch for embedders to fine-tune parts of the browser.
            For example, it lets embedders decide when the app cache can be used.
          </aside>
        </section>

        <section id="the-biggest-class">
          <aside class="notes">
            <p>One final thing about the code.
               I've mentioned a few times how large the codebase is,
               and that scares some people off.
               So I wanted to show you this:</p>
            <p><b>live code <code>find ./ -name "*.cc" | xargs du -s | sort -n</code></b></p>
            <p>Like I said, you're going to find weird code that you don't understand,
              and that's OK because nobody understands all of it and you're in good company.</p>
            <p><em>but</em></p>
            <p>Here we've got the largest source file in electron, atom_api_web_contents.
               And if we open up its class definition,
               we see it's full of things like <code>OpenDevTools()</code> and
               and <code>IsDevToolsOpened()</code>.</p>
            <p>Even though Electron takes time to learn,
               a lot of its code maps directly to concepts that you
               already know if you've ever written an Electron application.</p>
          </aside>
        </section>

        <section id="part-3-taking-action">
          <h4>Part 3 of 3</h4>
          <h2>Taking Action</h2>
          <aside class="notes">
            <p>OK so remember back to the beginning when I said if you've got chai,
               or IPC, or Windows, or Linux, or XYZ experience,
               that can give you a foothold.</p>
            <p>I also said that before Electron, I worked for Canonical on its
               Linux desktop. So here's a bug I fixed very early on using only
               my knowledge of Linux's GUI library named GTK+.</p>
            <p>You don't need any GTK+ experience to follow along.
               My point here is that, whichever of that shopping list of skills you have,
               you can do good without memorizing 60 million lines of code first.</p>
          </aside>
        </section>

        <section id="debugging">
          <img src="assets/bug-report.png"/>
          <aside class="notes">
            <p>The bug report's screenshot says it all: on Linux, the `alert()` dialog is showing a No Symbol icon.</p>
            <p>This should be easy to test.</p>
          </aside>
        </section>

        <section id="final-thoughts-on-code">
          <h3>Final thoughts on the codebase</h3>
          <ul>
          <li class="fragment">Electron is a good project for someone who knows X and wants to learn Y</li>
          <li class="fragment">You already understand more than you think</li>
          <li class="fragment">Don't Panic</li>
          </ul>
          <aside class="notes">
          <p>As said in the last slide, <b>(fragment)</b> you understand more than you think.</p>
          <p><b>(fragment)</b> When I started contributing to Electron, I'd never touched Node. So for me it was both unfamiliar *and* alien, and I stressed over that a lot.</p>
          <p>The thing to understand is you've got millions of lines of code -- <b>everyone</b> is lost to some degree.</p>
          <p>When I realized it's OK to be a <i>little</i> lost, that freed me up to stress about it less and focus and learn faster.</p>
          <p><b>(fragment)</b> As an aside, Chromium has a lot of solid engineering. [read fragment aloud here] The Chromium directory named `base/` holds general-use tools, mostly self-contained, so it's not a bad place to start. You'll find Chromium's string manipulation, memory management, callback binding, and so on.</p>
        </section>

        <section data-markdown data-separator-notes="XXX" data-background-video="assets/bugfix.webm" data-background-color="#000000">
          XXX
          make sure we have a fresh build

          let's run electron-quick-start

          open devtools

          and pull up an alert dialog.

          sure enough.

          Now, I'm pretending for this example I don't know whether Electron is using a GtkMessageDialog, a GtkDialog, or not using those at all but instead creating a custom GtkWindow.

          But I do know whatever it's using, that icon is getting shown by a call to gtk_widget_show(), because that's what every GTK+ widget uses, no matter what type of class is aggregating it.

          So I'll run the same test again inside a debugger and set gtk_widget_show() as a breakpoint.

          open devtools again...

          set the breakpoint... gdb is kind of slow.

          the alert again...

          cool. let's see where it's coming from.

          ok this noise here is C++'s version of the green terminal windows in the matrix. You get used to it.

          first thing I see here is it's in atom/browser/ui/message_box_gtk, which means it's likely our bug.

          I see an argument named 'icon' of type imageskia, so maybe someone is passing in a broken icon.

          let's open up atom/browser/ui/message_box_gtk line 49 and take a look.

          here's where the dialog is created, and sometimes these use a default icon depending on the dialog type.

          let's go back to the debugger and see what type was passed in.

          looks like that type is atom::MESSAGE_BOX_TYPE_NONE, so that's not the problem.

          Next I see us setting the dialog's image property if that imageskia isn't null.

          let's go back to the debugger and check.

          walk up the callstack

          and icon.isNull() is _true_, so this block of code is never reached, so this isn't the problem either.

          what else calls gtk_widget_show().

          here's a call that only happens when we have a checkbox label... that's not going to be it, but just for fun let's ask the debugger what checkbox_label is --

          yep, checkbox_label is an empty string.

          so let's keep looking for gtk_widget_show() calls.

          AH now this is promising.

          gtk_widget_show_all() tries to show its whole subtree of widgets, of UI components. 

          So maybe what's happening is GtkMessageDialog _always_ has an icon widget, but it's just not shown when the icon property's not set.

          If so, this call here would show that unset icon.

          That would be consistent with the no-icon symbol.

          Let's see what happens if we remove the `_all()` from this.

          rebuild

          restart the process

          pop up devools

          show an alert

          there we go!

          We got it.

          And although I knew some GTK+ to solve this bug, this one didn't really take any Electron.

          (fast transition to)
        </section>

        <section id="conclusions">
          <h3>What Have We Learned?</h3>
          <li class="fragment">Whether you know Electron, GTK+, Chromium, Node.js, Windows, JS, C++, Obj-C, Carbon, Linux, or Docker... those are <i>all</i> skills that you can use on Electron.</li>
        </section>

        <section data-markdown data-separator-notes="XXX" id="thanks">
          ### Thanks for listening!

          #### Further reading
          * https://electronjs.org/docs/development

          * https://cs.chromium.org/

          * https://www.chromium.org/developers/how-tos/getting-around-the-chrome-source-code

          * https://www.patreon.com/sindresorhus
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: false,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'socket.io/socket.io.js', async: true },
          { src: 'plugin/notes-server/client.js', async: true },
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/search/search.js', async: true },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });
    </script>

  </body>
</html>
