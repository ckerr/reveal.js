<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Electron Hacking for Beginners</title>

    <meta name="description" content="A gentle introduction to a very large codebase">
    <meta name="author" content="Charles Kerr">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/night.css" id="theme">
    <style>
      .secondary_text {
        font-size: smaller;
        font-style: italic;
        filter: brightness(66%);
      }
      .reveal section .why_image {
        background-color: transparent;
        border: none;
        height: 200px;
        width: 150px;
      }
      .filename {
        font: courier;
        font-size: 0.8em;
        color: lime;
        background-color: #222;
        word-break: keep-all;
      }
      .url {
        color: #0f0;
        text-decoration: underline;
      }
    </style>

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section id="title-page">
          <h2>Electron Hacking for Beginners</h2>
          <p>A gentle introduction to a very large codebase</p>
          <p>&nbsp;</p>
          <p>Charles Kerr<br/><span style="font-size: smaller">Microsoft's Electron Team</span></p>
          <aside class="notes">
            <p>Hi, I'm Charles Kerr. I'm part of the Electron team at Microsoft. There, I'm one of the Electron maintainers.</p>
            <p>And today I'm going to talk about why you should get involved with Electron's development.</p>
          </aside>
        </section>

        <section id="topics">
          <h3>Getting Involved!</h3>
          <ol>
            <li>Why?</li>
            <li>How?
              <ul>
                <li>Getting the code</li>
                <li>Building the code</li>
                <li>Understanding the code</li>
              </ul>
            </li>
            <li>Live coding demo</li>
          </ol>

          <aside class="notes">
          <p>So we'll go over why you would want to do that,</p>
          <p>how to do that,</p>
          <p> -- including the mechanics of getting and building the code, and finding your way around it--</p>
          <p>and we'll tie it all together with a live coding example.</p>
          <p>So. This talk is about coding, but if you're not a coder, there are other ways to help.</p>
          <p>If you're bilingual, there is a project to translate our documentation.</p>
          <p>If you're in QA, we have a group made up of QA people from other Electron apps.
             Come and learn from them.</p>
          <p>If you have an app with a beta channel and you want to help us find bugs in
             Electron's beta releases, come talk to us.</p>
          </aside>
        </section>

        <section id="why-get-involved">
          <h3>Why Get Involved?</h3>
          <div style="display: grid; grid-template-columns: 3fr 1fr 1fr 1fr 1fr; grid-column-gap: 0.5em">
            <div class="fragment"><img class="why_image" src="assets/tux.png"> <img class="why_image" src="assets/mac-os.png"></div>
            <div class="fragment"><img class="why_image" src="assets/Light-bulb-icon.png"/></div>
            <div class="fragment"><img class="why_image" src="assets/bag-of-money.png"/></div>
            <div class="fragment"><img class="why_image" style="height: 150px; padding-top: 33px" src="assets/happy.png"/></div>
            <div class="fragment"><img class="why_image" src="assets/infinity-gauntlet.png"/></div>
          </div>
          <aside class="notes">
            <p>So, why get involved?</p>
            <p><b>FRAGMENT (show tux)</b></p>
            <p>First, maybe you're a developer who uses more than one desktop OS and you like a world with apps that run on all of them.</p>
            <p>Would all the Electron apps that you use still exist
               if the people who made them had to write and test three separate native versions?</p>

            <p><b>FRAGMENT (show lightbulb)</b></p>
            <p>Maybe you want to put your skills to use and also learn new skills.
               Electron uses a <em>lot</em> of languages and tools.
               <ol>
                 <li>JavaScript</li>
                 <li>TypeScript</li>
                 <li>C++</li>
                 <li>Python</li>
                 <li>Objective C.</li>
                 <li>We use Mac APIs</li>
                 <li>Windows APIs</li>
                 <li>we use posix, GTK+, and dbus on Linux</li>
                 <li>our tests use chai</li>
                 <li>our CI uses docker</li>
                 <li>...and so many more. I literally could not name them all.</li>
               </ol></p>
            <p>And maybe that list feels overwhelming at first.
               But if you get just one thing from this talk, I want you to understand
               that <b>you can</b> do good things on Electron even if you only know one of those skills.
               <em>Nobody</em> understands the whole list, so you're in good company.
               And if you do know one or two of those things and want to learn more,
               Electron has so many more opportunities than your average project.</p>
            <p>Electron's code is big and isn't always easy, but it often it is.
               <b>You can</b> do good things on Electron even if you are just starting out.</p>

            <p><b>FRAGMENT (show bag of money)</b></p>
            <p>Maybe you're looking for better-paying work.</p>
            <p>There are a <b>lot</b> of apps shipping on Electron,
               but if Application X hits some weird issue,
               very few people know how to dig deep into Electron's source and fix it.</p>
            <p>I heard the manager on one Electron app say that
               if another team wanted their Electron person,
               they'd have to take them over that manager's dead body.</p>

            <p><b>FRAGMENT (show smiley)</b></p>
            <p>Related to the last two, maybe you're looking for more <em>interesting</em> work.</p>
            <p>That list of languages and technologies
               I just rattled off means that you can hack on Electron
               for a <b>long</b> time without stagnating, without getting bored.</p>

            <p><b>FRAGMENT (infinity gauntlet)</b></p>
            <p>Lastly, power. Influence.</p>
            <p>Electron is a community-based project. We've got a governance structure,
               a code of conduct, maintainers around the world -- but there's only about
               a dozen of us full-time.</p>
            <p>Anyone in this room, if they wanted to invest the time,
               can go from having no say to having a very prominent say.</p>
            <p>As long as it's not to the detriment of others, we're very flexible</p>

          </aside>
        </section>

        <section id="code-what-code">
          <h4>What code do I need?</h4>
          Electron, Node, and Chromium
          <p class="fragment">...and Node's dependencies, like brotli, http_parser, llhttp, nghttp2, v8, zlib </p>
          <p class="fragment">...and Chromium's dependencies, like Skia, Views, fido, mojo, libdbus, libaccessability, libpdf, libprotocol, ppapi, libnetwork_service, libgl_wrapper, libbluetooth</class></p>
          <p class="fragment">...and the dependencies' dependencies, like angle, blink, boringssl, breakpad, brotli, cacheinvalidation, ced, cld_3, crashpad, dav1d, dom_distiller, fontconfig, hunspell, iccjpeg, libsecret, srtp, vpx, webm, webp, libxml2, libxslt, libyuv, liblzma, libmodp_b64, openh264, opus, perfetto, pffft, protobuf, re2, sfntly, smhasher, snappy, sqlite, swiftshader, unrar, webrtc, yasm, zlib</p>
          <aside class="notes">
            <p>Alright, if any of those sounded interesting,
               the next thing to do is get the code.</p>

            <p>So, what do you need to get? Well as you know, Electron is Node plus Chromium plus features.</p>

            <p>And we compile all their sources to ensure everything's compatible.
               For example,
               everything needs to have the same compiler flags.
               And we also need to ensure that Chromium and Node use the same version of the javascript engine named V8.</p>

            <p><b>fragment</b>
            Oh yeah, v8. Node has some dependencies, and we need to build those too.</p>

            <p><b>fragment</b>
            And so does Chromium</p>

            <p><b>fragment</b>
            Oh, and Chromium's dependencies have dependencies too.
            When you add everything up, it's about 60 million LOC.
            </p>
          </aside>
        </section>

        <section id="introducing-electron-build-tools">
          <p style="color: #f00; text-decoration: line-through;">$ brew install</p>
          <p style="color: #f00; text-decoration: line-through;">$ npm install</p>
          <p style="color: #f00; text-decoration: line-through;">$ sudo apt install</p>
          <p class="url">https://github.com/electron/build-tools</p>
          <aside class="notes">
          And for added fun, you can't just install them.
          Chromium's dependencies aren't given by their version numbers; they use specific commit hashes.
          And Chromium has custom patches for its dependencies.
          Those have to be applied before building.
          Node patches V8, too.
          And Electron patches both Node <em>and</em> Chromium.

          <p>Chromium has a project named depot-tools exists to do all this wrangling.
            and Electron's docs show you how to do that manually.</p>

          <p>But Sam and Shelly and I recently wrote "electron build-tools",
             Which includes a command-line tool named "e" to handle all the minutia for you.
             <ul>
               <li>It fetches depot-tools and keeps it up-to-date,</li>
               <li>it has sensible defaults for git caching,</li>
               <li>by default it tries to speed up your build by seeing if it can reuse precompiled pieces made by our CI.</li>
               <li>While doing all this, it tries to "Just work" out-of-the-box,</li>
               <li>and it does other helpful things. We'll see some them later in this talk.</li>
             </ul>
             So, electron's build-tools is what I recommend.
          </p>

          <p>We're planning to make build-tools an npm package.
             For today, though, installing build-tools is still
             pretty straightforward.</p>
          <p>Let me open a terminal here and I'll show you.</p>
          <p><b>LIVE CODING ctrl-1 to install build tools</b></p>
          <p>As you can see, I don't have `e` yet.</p>
          <p>I am going to put it in my `electron` directory.
             That's path isn't required by any scripts; you can put it anywhere you like.</p>
          <p>If you've used npm apps, you've probably done this before:
             clone the repo from GitHub, cd into it, and npm install.</p>
          <p>Then I add the src directory to my path, and now my command line sees <code>e</code>.</p>
          <p>That's the easy part!</p>
          <p><b>VIDEO ENDS ctrl-0 and show e options</b></p>
          <p>So, let's see what we can do with `e`.
            When you're starting out,
            these first four commands are likely to be the first four you'll use:</p>
          <p><code>e init</code> creates a new project file.
             which remembers where you told it to keep the source code,
             and whether to make a test build or a release build.
             And it sets up reasonable defaults for build-time environment variables.</p>
          <p>Like I say, `e` tries to "just work", but to give you a sense of what
             I mean by the environment variables:
             You can look at the environment variables it injects by running <code>e show env</code>.</>
          <p>Here you see the git caching that I mentioned earlier,
             and these sccache variables are for what I said earlier about trying to reuse precompiled pieces from Electron's CI.</p>
             And <code>e show current --filename</code> tells you where your project file lives,
             so you can edit it by hand if you really need to.</p>
          <p><code>sync</code> synchronizes the source code.
             If you haven't checked out the code yet -- such as after running `e init` for the first time -- this will fetch it.
             If you've already checked it out before, this will bring it up-to-date.
             So for example you'll want to sync after checking out a different electron branch
             to ensure its dependencies match.
             Say you've checked out an older version of Electron --
             that older Electron code wants to compile with use older versions of Chromium and Node.</p>
          <p>The next two are even more straightforward:
             <code>make</code> makes it and <code>run</code> runs it.</p>
          <p>Lastly, you can combine init, sync, and make all together by calling
             init with the option <code>--bootstrap</code>.
             This is your one-liner to get from zero to an Electron executable.</p>
          <p><b>VIDEO ctrl-2 for bootstrap</b></p>
          <p>Let's see what that looks like.</p>
          <p>I'm going to run <code>e init</code>... oh actually let's time it to see how long it takes...
             Since we're going to fix a bug in our coding example,
             I'll keep the source in a directory named covalence-bug,
             this will be a testing build,
             I'll name the project file the same as the directory name,
             and I'll bootstrap it.
          <p>So now it's going to pull in and compile those sixty million lines of code that I mentioned.
             And that's about as fast as it sounds.
             Like I said, e does try to reuse precompiled pieces from our CI
             and it does do git caching so that followup calls to <code>e sync</code> are faster,
             but still.
             the first time is pretty harsh.
             There's a reason anandtech has a hardware benchmark that just lists Chromium build times.</p>
          <p>In fact, let's just speed up time a bit here...</p>
          <p>OK. That 'finished' line there means it ook 24 minutes to download the source.</p>
          <p>And there are 33 thousand pieces to build.</p>
          <p>Let's speed up time again...</p>
          <p>And you can see the bootstrap took about 2200 seconds, about 36 minutes.</p>
          <p>So, hooray! With a bit of patience, or the ability to speed up time, you too can build Electron!</p>
          <p>And because we've done that here, that means we now have code to look at!</p>
          <p>We'll go to the root directory that we specified in <code>e init</code>.</p>
          <p>And by the way, you can use <code>e show</code></p> to ask the current project file for this information, which is handy if you've got a lot of project files or if you're writing shell script helpers to get around.</p>
          <p>For example <code>e show current</code> confirms what we already knew, that covalence-bug is the active project file. And <code>e show root</code> shows what directory we told <code>e init</code> to use.</p>
          <p>So that means you can do something like <code>cd $(e show root)</code></p>
          <p>And when we do that, we get a directory full of who-knows-what.
            android? chromeos? Electron doesn't run on those; what is all this stuff?</p>
          <p>Here's what's going on:
             Out of those 60 million lines I mentioned, Electron is only about 70 thousand.
             Less than a tenth of one percent.
             Even Node, with <b>all</b> its dependencies included, is only about 5 million lines.
             Everything else is Chromium. Or its deps.</p>
          <p>Doing thing the Chromium Way has a lot of inertia, life is just
             easier when we use its directory layout and its build structure.
             So what you see here is more or less what you see when building Chromium.
             The one thing that's different is this electron folder here.
             That's where our one tenth of one percent is.
             We'll look at that in a minute,
             But that code will make a little more sense if we run through some Chromium highlights real quick.</p>
          </aside>
        </section>

        <section data-separator-notes="XXX" id="getting-around-the-chromium-codebase">
          <p><b>Electron's Most-Included Chromium Modules</b></p>
          <p style="font-size: 0.6em">See also: <a href="https://cs.chromium.org/" class="url">https://cs.chromium.org/</a>
          <ul>
            <li class="fragment"><span class="filename">base/</span> <span class="secondary_text">general utils, eg: string tokenizing, logging</span></li>
            <li class="fragment"><span class="filename">gin/</span> <span class="secondary_text">convenience utilities for the JavaScript engine v8</span></li>
            <li class="fragment"><span class="filename">blink/</span> <span class="secondary_text">rendering and layout</span></li>
            <li class="fragment"><span class="filename">ui/gfx/</span> <span class="secondary_text">simple graphics classes</span></li>
            <li class="fragment"><span class="filename">ui/views/</span> <span class="secondary_text">framework for using native windows</span></li>
            <li class="fragment"><span class="filename">content/</span> <span class="secondary_text">the core needed for a multi-process sandboxed renderer. (More about this in a moment.)</span></li>
            <li class="fragment"><span class="filename">components/</span> <span class="secondary_text">components that have <span class="filename">content/</span> as the uppermost layer they depend on (eg. printing)</span></li>
            <li class="fragment"><span class="filename">services/</span> <span class="secondary_text">cross-platform management of services</span></li>
          </ul>
          <aside class="notes">
            <p>These are the Chromium Modules that Electron includes the most.</p>
            <p>And I mean 'include' in the C++ sense, which is vaguely like JavaScript's require or import.</p>
            <p>Oh! And if you're following along, try going to cs.chromium.org,
               then opt into the new layout, and click on <code>chromium/src</code>.
               You'll see a sidebar with the same chromium code layout that we just looked at in a terminal
               And since Chromium's size makes it difficult to code search it in an IDE,
               cs.chromium can be very useful.</p>
            <ul>
              <li>The first module you should know about is <code>base</code>.
                  These are general purpose tools that anyone else can use.
                  this is where you'll find your string tokenizers,
                  command-line parsers, logging utils, C++ polyfills, and so on.</li>

              If you want to get familiar with the C++ code, this is the single best starting point.
              It's well-written,
              it's all self-contained,
              and Electron uses it everywhere.

              <li>gin: which is convenience utilities for the javascript engine named v8. 
                  This module is more complex, but might be another good starter candidate
                  if you're wanting to learn more about V8:
              <ul>
                <li> it's only a few thousand lines</li>
                <li> Electron uses it everywhere</li>
              </ul>
              </li>

              <li>blink is chrome's famous rendering and layout engine.
                  And it does a lot of heavy lifting for us.
                  But usually when Electron refers to blink,
                  it's because we need to include the declaration of a blink structure or a blink enumeration.
                  So while understanding Blink is useful, this is not where you'll spend most of your time.</li>

              <li>gfx: here are the fonts, color palettes, and rounded rectangles.
                  This builds on top of the 2D graphics library Skia, which I think is also used by Firefox.</li>

              <li>views (and aura): framework for native UI resources
                  like windows, widgets, textfields, menus.
                  One of Electron's biggest advantages is that it gives you access to native features,
                  so we have a lot of code that builds on top of views.</li>

              <li>next in the chromium stack is content and this is the most important one here.
                  It describes itself as "the core needed for a multi-process sandboxed renderer."
                  Which to me means it's a minimum viable code for a browser and browser only --
                  no extra features like spellcheck, printing, and so on --
                  and someone like Chromium can come along and build a full web browser around it,
                  or someone like Electron can come along and build Electron around it.
                  Content has a public API of classes, and also a reference implementation
                  named "content shell" which renders pages on all platforms.
                  If you're embedding Chromium in an application, content is where you'd start --
                  so let's come back to this module in the next slide.</li>

              <li>components: this is where you'll find most of those 
                  bells and whistles that you won't find in content --
                  they're important, but not intrinsic to content itself.
                  Here's where you'll find printing, translation detection,
                  autofill, bookmarks, you name it.</p>

              <li>finishing the list is services: services reside in their own processes and communicate only via IPC.
                  There's no link-time or run-time exposure, no sharing of global state.
                  Obviously, this has security benefits.
                  It also has pragmatic benefits.
                  For example, audio is a service. If your platform's audio just fails,
                  Chromium can stop and restart the audio service instead of the entire browser process.</li>
          </aside>
        </section>

        <section id="content-module">
          <aside class="notes">
            <p>OK that's the broad overview of Chromium, let's get back to the content module.</p>
            <p>topics:
               a couple of obvious ones:
                 common/ is code that's shared between these pieces,
                 utility/ is small utilities,
              `shell/` - as mentioned, this is content's basic browser.
              `renderer and browser`
                      If you've written a hello world in Electron, this duality probably looks familiar.
                      In Electron, the process that runs `package.json`'s `main` script is called
                      __the browser process__, sometimes also called __the main process__.
                      An Electron app always has exactly one browser process.
                      Each web page in Electron runs in its own process,
                      which is called __the renderer process__.
                      And this architecture in content is where that separation comes from.
              `public/` - This is the content module's public API.
                          It's how the outside world uses the content module,
                          The majority of Electron's C++ classes are subclasses from these public classes.
                          in fact, to 

          </aside>
        </section>

        <section>
          <div style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 1em">
            <div><!-- col 1 -->
              <h4>Chromium's<br/>Content Module:<br/>Public API</h4>
              <h5>(<span class="filename">src/content/public/</span>)</h5>
              <ul>
                <li><span class="filename">app/</span></li>
                <li><span class="filename" style="filter: brightness(120%);">browser/</span></li>
                <li><span class="filename">child/</span></li>
                <li><span class="filename">common/</span></li>
                <li><span class="filename" style="filter: brightness(120%);">renderer/</span></li>
                <li><span class="filename">test/</span></li>
              </ul>
            </div>
            <div><!-- col 2 -->
              <h4>Chromium's<br/>Content Module:<br/>Content Shell</h4>
              <h5>(<span class="filename">src/content/shell/</span>)</h5>
              <ul>
                <li><span class="filename">android/</span></li>
                <li><span class="filename">browser/</span></li>
                <li><span class="filename">common/</span></li>
                <li><span class="filename">gpu/</span></li>
                <li><span class="filename">renderer/</span></li>
                <li><span class="filename">utility/</span></li>
              </ul>
            </div>
          </div>
          <aside class="notes">
            <p>
            Now back to Chromium's content module.
            Content defines the interfaces for a bare-bones multiprocess browser.
            Like I said, if you're embedding Chromium, this is where you start.</p>
            </p>

            <p>
            Here, The left column shows the modules in content's public API.
            Most of Electron's C++ code is in service of subclasses these.
            </p>

            <p>
            And if you've written even Hello World in Electron,
            the separation of concerns between browser and renderer
            will already look familiar. This is where that separation
            in Electron comes from.
            </p>

            <p>
            As mentioned before, content has its own basic implementation called "content shell"
            and here on the right you can see its modules.
            So a lot of the time you can use this as reference code
            and see what pieces Electron re-used and what it
            couldn't reuse due to its own requirements.
            </p>

          </aside>
        </section>

        <section id="electron-modules">
          <div style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 1em">
            <!--<div style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 1em">-->
            <div><!-- col 1 -->
              <h4>Electron's JavaScript<br/>Modules</h4>
              <h5>(<span class="filename">src/electron/lib/</span>)</h5>
              <ul>
                <li><span class="filename">browser/</span></li>
                <li><span class="filename">common/</span></li>
                <li><span class="filename">content_script/</span></li>
                <li><span class="filename">isolated_renderer/</span></li>
                <li><span class="filename">renderer/</span></li>
                <li><span class="filename">sandboxed_renderer/</span></li>
                <li><span class="filename">worker/</span></li>
              </ul>
            </div>
            <div><!-- col 2 -->
              <h4>Electron's C++<br/>Modules</h4>
              <h5>(<span class="filename">src/electron/shell/</span>)</h5>
              <ul>
                <li><span class="filename">app/</span></li>
                <li><span class="filename">browser/</span></li>
                <li><span class="filename">common/</span></li>
                <li><span class="filename">renderer/</span></li>
                <li><span class="filename">utility/</span></li>
              </ul>
            </div>
          </div>
          <aside class="notes">
            <p>When you look at Electron's code,
               you'll see the same ideas in play.</p>
            <p>On the left here you'll see the JavaScript and typescript modules.
               This is the user-facing code that Electron applications import or require.</p>
            <p>On the right is the C++ layer that goes between lib and Chromium's content module.
               This is where we subclass from content's public APIs,
               where platform native features go,
               and where we tie into Node.</p>
            <p>In both of these columns,
               app, browser, common, renderer, and utility
               all carry the same meanings as in chromium's content module.</p>
          </aside>
        </section>

        <section id="finding-reference-points">
          <p>So if you get a crash in <span class="filename">electron/shell/browser/atom_browser_client</span>:</p>
          <p>
            <ul>
              <li>You know a reference impl is at <span class="filename">content/shell/browser/shell_content_browser_client.cc</span></li>
              <li>You know the parent class is at <span class="filename">content/public/browser/content_browser_client.h</span></li>
            </ul>
          </p>

          <aside class="notes">
            <p>So, putting this together, say you get a crash and your debugger says it's
               in electron/shell/browser/atom_browser_client. And you think to yourself,
               "well I know all those words, but I have no idea what that means."</p>
            <p>from the directory and the filename,
               you already know this is building on top of content.
               so you know where to look for a reference implementation.</p>
            <p>You also know where the parent class is,
               which is usually well-commented.</p>
          </aside>
        </section>

        <section id="finding-the-answer">
          <p>And when you open up <span class="filename">content/public/browser/content_browser_client.h</span>...</p>
          <p><pre><code>// Embedder API (or SPI) for participating in browser
// logic, to be implemented by the client of the content browser.
// See ChromeContentBrowserClient for the principal impl.
// The methods are assumed to be called on the UI thread unless
// otherwise specified. Use this "escape hatch" sparingly,
// to avoid the embedder interface ballooning and becoming
// very specific to Chrome.
class CONTENT_EXPORT ContentBrowserClient {</code></pre></p>
          <p><pre><code>// Allow the embedder to control if an AppCache can be used
// for the given url. This is called on the UI thread.
virtual bool AllowAppCache(const GURL& manifest_url,
                           const GURL& first_party,
                           BrowserContext* context);</code></pre></p>
          <aside class="notes">
            And when you look at the parent class, you learn that BrowserClient is a catch-all
            escape hatch for embedders to fine-tune parts of the browser.
            For example, it lets embedders decide when the app cache can be used.
          </aside>
        </section>

        <section data-markdown data-separator-notes="XXX" id="the-biggest-class">
          FIXME: is this content needed?
          FIXME: there is no flow from previous slide
          FIXME: this slide is even uglier than the others

          **Excerpt from Electron's largest class, atom::api::WebContents**
          ```cpp
            void LoadURL(const GURL& url, const mate::Dictionary& opts);
            base::string16 GetTitle() const;
            bool IsLoading() const;
            void Stop();
            void ReloadIgnoringCache();
            void GoBack();
            void GoForward();
            bool IsCrashed() const;
            void SetUserAgent(const std::string& user_agent);
            std::string GetUserAgent();
            void InsertCSS(const std::string& css);
            void OpenDevTools(mate::Arguments* args);
          ```

          XXX
          This <i>is</i> the largest class we've got.
          And, while the size of the whole project can be overwhelming,
          the individual pieces aren't actually that scary.

          To be clear: no, I'm not saying Electron is easy.
          Some of it is, but a lot of it isn't.

          But if you've written Electron apps,
          if you've used `win.loadURL()` or `win.getTitle()`,
          you already see the big picture, and that can be your guide
          when you're reading and learning the littler pictures.
        </section>

        <section id="crazy-wall">
          <img src="assets/my-brain-is-full.jpg"/>
          <aside class="notes">
            <p>OK that's probably enough theory.</p>
            <p>You all now know how to get and build one of the world's largest open source codebases.</p>
            <p>You have an idea of how 11 million puzzle pieces fit together.</p>
            <p>And what you don't know, you know where to start looking to find out.</p>
            <p>Let's do something with all this knowledge.</p>
          </aside>
        </section>

        <section id="part-3-taking-action">
          <h4>Part 3 of 3</h4>
          <h2>Taking Action</h2>
          <aside class="notes">
            <p>OK so remember back to the beginning when I said if you've got chai,
               or IPC, or Windows, or Linux, or XYZ experience,
               that can give you a foothold.</p>
            <p>I also said that before Electron, I worked for Canonical on its
               Linux desktop. So here's a bug I fixed very early on using only
               my knowledge of Linux's GUI library named GTK+.</p>
            <p>You don't need any GTK+ experience to follow along.
               My point here is that, whichever of that shopping list of skills you have,
               you can do good without memorizing 60 million lines of code first.</p>
          </aside>
        </section>

        <section id="debugging">
          <img src="assets/bug-report.png"/>
          <aside class="notes">
            <p>The bug report's screenshot says it all: on Linux, the `alert()` dialog is showing a No Symbol icon.</p>
            <p>This should be easy to test.</p>
          </aside>
        </section>

        <section id="final-thoughts-on-code">
          <h3>Final thoughts on the codebase</h3>
          <ul>
          <li class="fragment">Electron is a good project for someone who knows X and wants to learn Y</li>
          <li class="fragment">You already understand more than you think</li>
          <li class="fragment">Don't Panic</li>
          </ul>
          <aside class="notes">
          <p>As said in the last slide, <b>(fragment)</b> you understand more than you think.</p>
          <p><b>(fragment)</b> When I started contributing to Electron, I'd never touched Node. So for me it was both unfamiliar *and* alien, and I stressed over that a lot.</p>
          <p>The thing to understand is you've got millions of lines of code -- <b>everyone</b> is lost to some degree.</p>
          <p>When I realized it's OK to be a <i>little</i> lost, that freed me up to stress about it less and focus and learn faster.</p>
          <p><b>(fragment)</b> As an aside, Chromium has a lot of solid engineering. [read fragment aloud here] The Chromium directory named `base/` holds general-use tools, mostly self-contained, so it's not a bad place to start. You'll find Chromium's string manipulation, memory management, callback binding, and so on.</p>
        </section>

        <section data-markdown data-separator-notes="XXX" data-background-video="assets/bugfix.webm" data-background-color="#000000">
          XXX
          make sure we have a fresh build

          let's run electron-quick-start

          open devtools

          and pull up an alert dialog.

          sure enough.

          Now, I'm pretending for this example I don't know whether Electron is using a GtkMessageDialog, a GtkDialog, or not using those at all but instead creating a custom GtkWindow.

          But I do know whatever it's using, that icon is getting shown by a call to gtk_widget_show(), because that's what every GTK+ widget uses, no matter what type of class is aggregating it.

          So I'll run the same test again inside a debugger and set gtk_widget_show() as a breakpoint.

          open devtools again...

          set the breakpoint... gdb is kind of slow.

          the alert again...

          cool. let's see where it's coming from.

          ok this noise here is C++'s version of the green terminal windows in the matrix. You get used to it.

          first thing I see here is it's in atom/browser/ui/message_box_gtk, which means it's likely our bug.

          I see an argument named 'icon' of type imageskia, so maybe someone is passing in a broken icon.

          let's open up atom/browser/ui/message_box_gtk line 49 and take a look.

          here's where the dialog is created, and sometimes these use a default icon depending on the dialog type.

          let's go back to the debugger and see what type was passed in.

          looks like that type is atom::MESSAGE_BOX_TYPE_NONE, so that's not the problem.

          Next I see us setting the dialog's image property if that imageskia isn't null.

          let's go back to the debugger and check.

          walk up the callstack

          and icon.isNull() is _true_, so this block of code is never reached, so this isn't the problem either.

          what else calls gtk_widget_show().

          here's a call that only happens when we have a checkbox label... that's not going to be it, but just for fun let's ask the debugger what checkbox_label is --

          yep, checkbox_label is an empty string.

          so let's keep looking for gtk_widget_show() calls.

          AH now this is promising.

          gtk_widget_show_all() tries to show its whole subtree of widgets, of UI components. 

          So maybe what's happening is GtkMessageDialog _always_ has an icon widget, but it's just not shown when the icon property's not set.

          If so, this call here would show that unset icon.

          That would be consistent with the no-icon symbol.

          Let's see what happens if we remove the `_all()` from this.

          rebuild

          restart the process

          pop up devools

          show an alert

          there we go!

          We got it.

          And although I knew some GTK+ to solve this bug, this one didn't really take any Electron.

          (fast transition to)
        </section>

        <section id="conclusions">
          <h3>What Have We Learned?</h3>
          <li class="fragment">Whether you know Electron, GTK+, Chromium, Node.js, Windows, JS, C++, Obj-C, Carbon, Linux, or Docker... those are <i>all</i> skills that you can use on Electron.</li>
        </section>

        <section data-markdown data-separator-notes="XXX" id="thanks">
          ### Thanks for listening!

          #### Further reading
          * https://electronjs.org/docs/development

          * https://cs.chromium.org/

          * https://www.chromium.org/developers/how-tos/getting-around-the-chrome-source-code

          * https://www.patreon.com/sindresorhus
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: false,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'socket.io/socket.io.js', async: true },
          { src: 'plugin/notes-server/client.js', async: true },
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/search/search.js', async: true },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });
    </script>

  </body>
</html>
